import customtkinter as ctk
from customtkinter import *

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter, A4

from reportlab.pdfbase import pdfmetrics 
from reportlab.pdfbase.ttfonts import TTFont

from csv import reader

from os import listdir, remove, startfile, mkdir, getlogin, path

from shutil import copy2

from customtkinter import filedialog

from tkinter import *
from tkinter.ttk import *
from tkinter import messagebox
from tkcalendar import *

from PIL import Image

from random import shuffle

import sqlite3 as sql

from datetime import datetime
from time import time, mktime

# date_epoch = mktime(datetime.strptime('23/06/2024', "%d/%m/%Y").timetuple())
# print(date_epoch)
# print(time())


#GERANDO BASE DE DADOS PARA ETIQUETAS
def Data_Gen():
    
    listaN = list(range(10000,100000))

    listaN1 = list(range(100000,1000000))

    listaN2 = list(range(1000000,10000000))

    shuffle(listaN)

    shuffle(listaN1)

    shuffle(listaN2)

    Lista_Geral = listaN + listaN1 + listaN2 
    
    
    diret = mkdir('main_files/Label Data-Frame')


    count = 0
    while count != 1000-1:
        with open(f'main_files/Label Data-Frame/Label_Data-{count}.csv','w') as arq:
            
            # tempo_inicial = time()
            
            for n in range(0+(10000*count),10000+(10000*count)):
                if n == 10000+(10000*count)-1:
                    arq.write(f'{Lista_Geral[n]}')
                    break
                arq.write(f'{Lista_Geral[n]}\n')
                # Lista_Geral.pop(0)
                
            # tempo_final = time() 
            # print(f'{tempo_final - tempo_inicial:.1f} segundos')
            print(f'Label_Data-{count} CRIADO\n')
            
            count += 1
    


#OBTENDO O CAMINHO PARA SALVAR PDF EM LOCAL DESEJADO
def Getting_Path():
    
    caminho = filedialog.askdirectory(title = "Selecione sua pasta de destino")
    
    return caminho
    



#LENDO O ARQUIVO, RETORNANDO LISTA E FAZENDO FOLLOW-UP
def Reading_Data():
    
    lista_arq = listdir('main_files/Label Data-Frame')
    
    #CASO OS DADOS TENHAM SE ESGOSTADOS
    if lista_arq == []:
        listaNF = []
        return listaNF
    
    #LENDO OS DADOS
    with open(f'main_files/Label Data-Frame/{lista_arq[0]}','r') as arq:
        csv_arq = list(reader(arq))
        
        #TRATANDO POSSÍVEIS ERROS DE ALTERAÇÃO DADOS
        while len(csv_arq) < 80:
            remove(f'main_files/Label Data-Frame/{lista_arq[0]}')
            lista_arq = listdir('main_files/Label Data-Frame')
            if lista_arq == []:
                listaNF = []
                return listaNF
                break
            with open(f'main_files/Label Data-Frame/{lista_arq[0]}','r') as arq:
                csv_arq = list(reader(arq))
        
        listaWT = []
        
        for n in range(0,80):
            listaWT.append(csv_arq[n][0])
            # print(csv_arq[n][0])
    
    #ATUALIZANDO OS ARQUIVOS DE DADOS:
    if len(csv_arq) > 80:
        
        with open(f'main_files/Label Data-Frame/{lista_arq[0]}','w') as arq:
            
            N = len(csv_arq[80:])
            for n in range(0,N):
                if n == N-1:
                    arq.write(f'{csv_arq[80:][n][0]}')
                    break
                arq.write(f'{csv_arq[80:][n][0]}\n')
        
        
    else:
        remove(f'main_files/Label Data-Frame/{lista_arq[0]}')
        
    
    return listaWT




#GERANDO O ARQUIVO PDF DE ETIQUETAS COM IDs
def Label_Model(listaWT,tipo,caminho):
    
    #PARÂMETROS DE ENTRADA
    c = caminho
    t = tipo #EC,PT,MP or GR
    l = listaWT
    
    #CASO SE ESGOTE O BANCO DE DADOS
    if l == [] :
        
        count = 0
        lista_pg = []
        for n in range(0,20):
            lista_lnh = []
            for i in range(0,4):
                # print(count)
                lista_lnh.append('NoDataFound')
                count += 1
                
        
            lista_pg.append(lista_lnh)
    
    #TRATANDO LISTA DE IDS
    else:
        count = 0
        # lista = []
        # for j in range(0,80):
        lista_pg = []
        for n in range(0,20):
            lista_lnh = []
            for i in range(0,4):
                # print(count)
                lista_lnh.append(f'{t} '+str(l[count])[0:2]+
                                      ' '+str(l[count])[2:4]+
                                      ' '+str(l[count])[4:])
                count += 1
                
        
            lista_pg.append(lista_lnh)
        # lista.append(lista_pg)
    
    time_mark = str(datetime.now())[:-7].replace(':',';')
    
    file_name = f'Etiquetas {time_mark} {getlogin()}.pdf'
    
    f = 25.4/72
    
    #CRIANDO PDF DE ETIQUETAS COM REPORTLAB
    pdf = canvas.Canvas(f'main_files/PDFs_done/{file_name}',pagesize = letter)
    
    font = 'arialbd.ttf'
    pdfmetrics.registerFont(TTFont(font, 'main_files/'+font))
    
    
    # count = 0
    # for pg in lista:
        
    count1 = 0
    for linha in lista_pg:
        
        count2 = 0 
        for cell in linha:
            pdf.drawBoundary(1, (14.3+0.85)/f+count2*(47.5/f),
                              254/f-count1*(12.7/f), 44/f, 10.8/f)
            pdf.setFont(font,18)
            pdf.drawCentredString((13.2+0.3)/f+(47.5/(2*f))+count2*(47.5/f),
                                  250.8/f+(12.7/(2*f))-count1*(12.7/f),
                                  str(lista_pg[count1][count2]))
            count2 += 1
        
        count1 += 1
            
        # count += 1
        # pdf.showPage()
        
    pdf.save()
    
    #SALVANDO CÓPIA DO ARQUIVO
    copy2(f'main_files/PDFs_done/{file_name}', c)
    
    #ABRINDO ARQUIVO
    startfile(c+f'/{file_name}')

# PEGANDO INFORMAÇÕES DA TELA
root = Tk()
ScreenX,ScreenY = root.winfo_screenwidth(),root.winfo_screenheight()
root.destroy()
# print(ScreenX,ScreenY)



######## CRIANDO E MANIPULANDO BANCO DE DADOS EM SQL ########################################### 
DB_Name = 'Stock Data'
DB_caminho = f'main_files/Data Base/{DB_Name}.db'
Table_Stock = 'Stock_Data'
Table_Trace = 'Stock_Data_Trace'
Table_Resp =  'Stock_Data_Resp'
Table_Códigos = 'Stock_Data_Cod'
Table_Correções = 'Stock_Data_Corrections'

#Crinado tabela do banco de dados
def create_db():
    
    if path.exists(DB_caminho) == False:
        
        if path.exists('main_files/Data Base') == False:
            
            mkdir('main_files/Data Base')
        
        connection = sql.connect(f'{DB_caminho}')
        blinker = connection.cursor() #como se fosse o cursor do prompt do SQL
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Stock}(   Identificador TEXT,
                                                                        Id INTEGER PRIMARY KEY,
                                                                        Código NUMERIC,
                                                                        Validade NUMERIC,
                                                                        Responsável TEXT,
                                                                        Volume NUMERIC,
                                                                        Obs TEXT,
                                                                        Time_Stamps_Login NUMERIC
                                                                        )""")
        connection.commit()

        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Trace}(   Identificador TEXT,
                                                                        Id INTEGER,
                                                                        Código NUMERIC,
                                                                        Validade NUMERIC,
                                                                        Responsável TEXT,
                                                                        Volume NUMERIC,
                                                                        Obs TEXT,
                                                                        Time_Stamps_Login NUMERIC,
                                                                        Time_Stamps_Login_Trace NUMERIC,
                                                                        Status TEXT
                                                                        )""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Resp}(Responsáveis TEXT)""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Códigos}(Códigos NUMERIC)""")
        connection.commit()
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('')""")
        connection.commit()
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('')""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Correções}(old TEXT,
                                                                         new TEXT,
                                                                         Time_Stamps_Login NUMERIC)""")
        connection.commit()
        
        
        connection.close()
    
create_db()    

#Buscando dados    
def fetch_itens(tabela):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT * FROM {tabela}")
    itens = blinker.fetchall() #me retorna uma lista de tuplas
    connection.close()
    
    return itens

#criando a função buscar para sistema de busca filtrado
def buscar(Filtro,Valor_Busca):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    if Filtro == 'Id':
        blinker.execute(f"SELECT * FROM {Table_Stock} WHERE {Filtro} = {Valor_Busca}")
        itens = blinker.fetchall() 
    else:
        blinker.execute(f"SELECT * FROM {Table_Stock} WHERE {Filtro} = '{Valor_Busca}'")
        itens = blinker.fetchall()
    connection.close()
    
    return itens

#criando função para analisar dados de responsáveis específicos
def busca_relatório(Valor_Busca):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT Id,Validade FROM {Table_Stock} WHERE Responsável = '{Valor_Busca}'")
    itens = blinker.fetchall()
    connection.close()
    return itens

#criando função para contar itens vencidos e prestes a vencer
def N_vencidos(data_list,option):
    
    if option == 1:
        
        itens = []
        for item in data_list:
            if (mktime(datetime.strptime(item[1], "%d/%m/%Y").timetuple())+86399) <= time():
                itens.append(item[0])
        return itens
    
    elif option == 0:
        
        itens = []
        for item in data_list:
            if  (
                ((mktime(datetime.strptime(item[1], "%d/%m/%Y").timetuple())+86399) >= time()) 
                and ((mktime(datetime.strptime(item[1], "%d/%m/%Y").timetuple())+86399) <= (time() + (86400*15)))
                ):
                itens.append(item[0])
        return itens
    
    else:
        
        itens = []
        for item in data_list:
            if ((mktime(datetime.strptime(item[1], "%d/%m/%Y").timetuple())+86399) > (time() + (86400*15))):
                itens.append(item[0])
        return itens
    
#criando função para analisar dados de responsáveis específicos
def busca_relatório_pdf_gen(Lista_Busca):
    
    Data = []
    
    for n in range(len(Lista_Busca)):
        blinker.execute(f"""SELECT Identificador,Id,Código,Validade,Volume FROM {Table_Stock} WHERE Id = {Lista_Busca[n]}""")
        itens = blinker.fetchone()
        Data.append(itens)
    connection.close()
    
    return Data



#convertendo lista de tuplas para lista
def tuple_to_list(tupla):
    lista = []
    for linha in tupla:
        lista.append(linha[0])
    lista.sort()
    return lista
    

#craindo função para identificar se um ID já foi cadastrado
def id_exists(ID):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Stock} WHERE Id = {ID}") #SELECT COUNT(*) FROM {Table} WHERE Id = {ID}
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False                                                  #result = blinker.fetchone
    
#craindo função para identificar se um Código já foi cadastrado
def codigo_exists(Código):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Códigos} WHERE Códigos = '{Código}'")
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False 

#craindo função para identificar se uma pessoa já foi cadastrada
def resp_exists(Responsável):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Resp} WHERE Responsáveis = '{Responsável}'")
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False 

#buscando OBS para mostrar no campo de observações
def fetch_OBS(ID):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT Obs FROM {Table_Stock} WHERE id = {ID}")
    itens = blinker.fetchall()[0] #me retorna uma lista de tuplas
    connection.close()
    
    return itens

#Inserindo dados do íten
def insert_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS):
    
    connection = sql.connect(f"{DB_caminho}")
    Time_Stamps_Login = str(datetime.now())+str(getlogin())
    blinker = connection.cursor()
    blinker.execute(f"""INSERT INTO {Table_Stock}(  Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login) VALUES
                                                    ('{Identificador}',
                                                     {ID},
                                                    '{Código}',
                                                    '{Validade}',
                                                    '{Responsável}',
                                                    '{Volume}',
                                                    '{OBS}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}')""")
    connection.commit()
    
    if codigo_exists(Código) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('{Código}')""")
        connection.commit()
    else:
        pass
    
    if resp_exists(Responsável) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('{Responsável}')""")
        connection.commit()
    else:
        pass
    
    
    connection.close()
    
#Atualizando itens
def update_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f'SELECT * FROM {Table_Stock} WHERE Id = {ID}')
    item = blinker.fetchall()
    blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login,
                                                    Time_Stamps_Login_Trace,
                                                    Status) VALUES
                                                    ('{item[0][0]}',
                                                     {item[0][1]},
                                                    '{item[0][2]}',
                                                    '{item[0][3]}',
                                                    '{item[0][4]}',
                                                    '{item[0][5]}',
                                                    '{item[0][6]}',
                                                    '{item[0][7]}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                    'UPDATED')""")
    connection.commit()

    blinker.execute(f"""UPDATE {Table_Stock} SET    Identificador = '{Identificador}',
                                                    Id = {ID},
                                                    Código = '{Código}',
                                                    Validade = '{Validade}',
                                                    ResponsáveL = '{Responsável}',
                                                    Volume = '{Volume}',
                                                    Obs = '{OBS}',
                                                    Time_Stamps_Login = '{str(datetime.now())[:19]+' '+str(getlogin())}'
                                                    WHERE Id = {ID}""")
                                                    
    connection.commit()
    
    if codigo_exists(Código) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('{Código}')""")
        connection.commit()
    else:
        pass
    
    if resp_exists(Responsável) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('{Responsável}')""")
        connection.commit()
    else:
        pass
    
    connection.close()

#Deletando dados
def delete_itens(ID):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f'SELECT * FROM {Table_Stock} WHERE Id = {ID}')
    item = blinker.fetchall()
    blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login,
                                                    Time_Stamps_Login_Trace,
                                                    Status) VALUES
                                                    ('{item[0][0]}',
                                                     {item[0][1]},
                                                    '{item[0][2]}',
                                                    '{item[0][3]}',
                                                    '{item[0][4]}',
                                                    '{item[0][5]}',
                                                    '{item[0][6]}',
                                                    '{item[0][7]}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                    'DELETED')""")
    connection.commit()

    blinker.execute(f'DELETE FROM {Table_Stock} WHERE Id = {ID}')
    connection.commit()
    connection.close()
    
#lista de itens vencidos
def lista_vencidos():
    
    Base_total = fetch_itens(Table_Stock)
    itens_vencidos = []
    for item in Base_total:
        if (mktime(datetime.strptime(item[3], "%d/%m/%Y").timetuple())+86399) <= time():
            itens_vencidos.append(item)
    return itens_vencidos

#função para retornar uma lista de itens vencidos em um determinado periodo de tempo futuro
def lista_vencidos_em(dias):
    Base_total = fetch_itens(Table_Stock)
    itens_vencidos = []
    for item in Base_total:
        if  (
            ((mktime(datetime.strptime(item[3], "%d/%m/%Y").timetuple())+86399) >= time()) 
            and ((mktime(datetime.strptime(item[3], "%d/%m/%Y").timetuple())+86399) <= (time() + (86400*dias)))
            ):
            itens_vencidos.append(item)
    return itens_vencidos

#função para retornar uma lista de itens vencidos em um determinado periodo de tempo futuro
def lista_vencidos_daqui(dias):
    Base_total = fetch_itens(Table_Stock)
    itens_vencidos = []
    for item in Base_total:
        if (mktime(datetime.strptime(item[3], "%d/%m/%Y").timetuple())+86399) >= (time() + (86400*(dias-1))+86399):
            itens_vencidos.append(item)
    return itens_vencidos

#criando função para correção dos dados de responsáveis e códigos
def data_correction(data_wrong,data_right,campo,correction_type):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    
    if campo == 'Responsáveis':
        
        if correction_type == 'Atualizar':
            
            if resp_exists(data_right) == False:
                blinker.execute(f"""UPDATE {Table_Resp} SET Responsáveis = '{data_right}' 
                                WHERE Responsáveis = '{data_wrong}'""")
                connection.commit()
            else:
                blinker.execute(f"DELETE FROM {Table_Resp} WHERE Responsáveis = '{data_wrong}'")
                connection.commit()
            
            blinker.execute(f"""INSERT INTO {Table_Correções} (old,new,Time_Stamps_Login)
                                VALUES ('{data_wrong}','{data_right}',
                                        '{str(datetime.now())[:19]+' '+str(getlogin())+' Responsável'}')""")
            connection.commit()
            
            blinker.execute(f"""SELECT * FROM {Table_Stock} WHERE Responsável = '{data_wrong}'""")
            itens = blinker.fetchall()
            
            for item in itens:
                blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                                Id,
                                                                Código,
                                                                Validade,
                                                                ResponsáveL,
                                                                Volume,
                                                                Obs,
                                                                Time_Stamps_Login,
                                                                Time_Stamps_Login_Trace,
                                                                Status) VALUES
                                                                ('{item[0]}',
                                                                 {item[1]},
                                                                '{item[2]}',
                                                                '{item[3]}',
                                                                '{item[4]}',
                                                                '{item[5]}',
                                                                '{item[6]}',
                                                                '{item[7]}',
                                                                '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                                'Correção-Código')""")
            connection.commit()
            
            for item in itens:
                blinker.execute(f"""UPDATE {Table_Stock} SET Responsável = '{data_right}' 
                                WHERE Id = {item[1]}""")
            connection.commit()
            connection.close()
        
        else:
            
            blinker.execute(f"DELETE FROM {Table_Resp} WHERE Responsáveis = '{data_wrong}'")
            connection.commit()
            connection.close()
    
    else:
        
        if correction_type == 'Atualizar':
            
            if codigo_exists(data_right) == False:
                blinker.execute(f"""UPDATE {Table_Códigos} SET Códigos = '{data_right}' 
                                WHERE Códigos = '{data_wrong}'""")
                connection.commit()
            else:
                blinker.execute(f"DELETE FROM {Table_Códigos} WHERE Códigos = '{data_wrong}'")
                connection.commit()
            
            blinker.execute(f"""INSERT INTO {Table_Correções} (old,new,Time_Stamps_Login)
                                VALUES ('{data_wrong}','{data_right}',
                                        '{str(datetime.now())[:19]+' '+str(getlogin())+' Código'}')""")
            connection.commit()
            
            blinker.execute(f"""SELECT * FROM {Table_Stock} WHERE Código = '{data_wrong}'""")
            itens = blinker.fetchall()
            
            for item in itens:
                blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                                Id,
                                                                Código,
                                                                Validade,
                                                                ResponsáveL,
                                                                Volume,
                                                                Obs,
                                                                Time_Stamps_Login,
                                                                Time_Stamps_Login_Trace,
                                                                Status) VALUES
                                                                ('{item[0]}',
                                                                 {item[1]},
                                                                '{item[2]}',
                                                                '{item[3]}',
                                                                '{item[4]}',
                                                                '{item[5]}',
                                                                '{item[6]}',
                                                                '{item[7]}',
                                                                '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                                'Correção-Responsável')""")
            connection.commit()
            
            for item in itens:
                blinker.execute(f"""UPDATE {Table_Stock} SET Código = '{data_right}' 
                                WHERE Id = {item[1]}""")
            connection.commit()
            connection.close()
        
        else:
            
            blinker.execute(f"DELETE FROM {Table_Códigos} WHERE Códigos = '{data_wrong}'")
            connection.commit()
            connection.close()
                
                            
    
    



######## CRIANDO INTERFACE GRÁFICA ################################################################
class App(ctk.CTk): # App = ctk.CTk
    
    def __init__(self):
        super().__init__()
        self.window_config()
        self.tema_config()
        self.frontend()
        
        
        
    def window_config(self):
        self.title("SPSLab - Controle de Armazenamento")
        x1,y1 = 1000,650
        self.iconbitmap("PPG ICON.ico")
        self.geometry(f"{x1}x{y1}+{(ScreenX-x1)//2}+{(ScreenY-y1)//4}")
        self._set_appearance_mode("system")
        # self.resizable(width=False, height=False)
        self.minsize(width=x1,height=y1)
        
    
    def tema_config(self):
        
        self.switch_var = ctk.StringVar(value="system")
        
        def set_tema():
            
            if self.switch_var.get() =="light":
                ctk.set_appearance_mode("light")
                
            else:
                ctk.set_appearance_mode("dark")
                
                
        
        self.switch = ctk.CTkSwitch(self, text = None, variable=self.switch_var, 
                                    onvalue= "dark", offvalue="light", command=set_tema)
        self.switch.place(x=25,y=20)
        
    
    def frontend(self):
        
        self.Label_logo = ctk.CTkLabel(self, text="                      We protect and\n                      beautify the world™", 
                                       font=("helvitica",12), justify = "left" )
        self.Label_logo.place(relx=0.02,rely=0.927)#relx=0.09,rely=0.93)
        
        #Logo
        if self.switch_var.get() =="light":
            logo = ctk.CTkImage(light_image=Image.open("PPG LOGO2.png"), size=(250*0.25,90*0.25))
        else:
            logo = ctk.CTkImage(dark_image=Image.open("PPG LOGO2.png"), size=(153*0.40,120*0.40))
            
        self.logo_Label = ctk.CTkLabel(self, text=None,image=logo)
        self.logo_Label.place(relx=0.02,rely=0.91)
        
        
        self.Label = ctk.CTkLabel(self, text="Sistema de Controle de Armazenamento", font=("arial bold",30))
        self.Label.pack(pady = 20)
        
        self.tabview = ctk.CTkTabview(self,
                                      width = 700,
                                      height = 510,
                                      corner_radius = 8,
                                      border_width = 2,
                                      segmented_button_fg_color="grey",
                                      segmented_button_selected_color="#037",
                                      segmented_button_unselected_hover_color="#111",
                                      segmented_button_unselected_color="#333")
        self.tabview.pack(pady = 0)
        self.tabview.add("Controle de Dados")
        self.tabview.add("Listagem")
        self.tabview.add("Relatório")
        self.tabview.add("Etiquetas")
        self.tabview.add("Correções")
        self.tabview.tab("Controle de Dados").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Listagem").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Relatório").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Etiquetas").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Correções").grid_columnconfigure(1, weight=1)
        
        
        ##### CRINADO ABA DE "Etiquetas" #################################################################
        
        self.Hang_Tags_Label = ctk.CTkLabel(self.tabview.tab("Etiquetas"), text="Escolha um Identificador",
                                            font=("arial bold",30))
        self.Hang_Tags_Label.pack(pady=20)
        
        #criando variável para radiobuttons
        self.Tag_type = ctk.IntVar(value=0)
        
        #criando função para pegar valores de cada etiqueta
        def tipo():
            dictionary = {1:'EC',2:'PT',3:'MP',4:'GR'}
            return dictionary[self.Tag_type.get()]
        
        #criando RadioButtons
        dtry = {1:' EC',2:' PT',3:' MP',4:' GR'}
        for n in range(1,5):
            self.RBt = CTkRadioButton(self.tabview.tab("Etiquetas"), text = dtry[n], command = tipo , 
                                      variable = self.Tag_type , value = n, font=("arial bold",40))
            self.RBt.pack(pady=12)
        
        #definindo função para geração de PDF de etiquetas
        def Gerar_PDF():
            
            if self.Tag_type.get() != 0:
                
                try:
                    caminho = Getting_Path()
                    
                    Label_Model(Reading_Data(), tipo(), caminho)
                except:
                    pass
                
            else:
                messagebox.showerror(title='Erro de Seleção', message='Por favor, selecione\numa das opções' )
            pass
        
        #criando botão para geração de PDF de etiquetas
        self.B1 = CTkButton(self.tabview.tab("Etiquetas"), text = "Gerar Etiquetas",command = Gerar_PDF, 
                                font=("arial bold",18),fg_color="#ba0606")
        self.B1.pack(pady = 25)
        
        #criando Label de Aviso
        self.Label_aviso = ctk.CTkLabel(self.tabview.tab("Etiquetas"), text="* No momento da impressão selecione o tamanho Carta",
                                            font=("arial",12))
        self.Label_aviso.pack()
        
        
        ##### CRIANDO ABA DE "Controle de Dados" #################################################################
        
        # criando calendário para seleção de validade
        self.Calen_Validade = Calendar(self.tabview.tab("Controle de Dados"),selectmode = 'day', 
                                       date_pattern = 'dd/mm/y',locale="pt_BR" )
        self.Calen_Validade.place(x=415,y=25)
        
        # criando barra de buscar de itens
        self.Label_Busca_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Busca:', 
                                              font=("arial",16,"bold"))
        self.Label_Busca_entry.place(x=18.5,y=0)
        self.Busca_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                        width=200, height=35, font=('arial',14))
        self.Busca_entry.place(x=18,y=25)
        
        
        
        # criando Label para ComboBox de filtro
        self.Label_Filtro = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Filtro:', 
                                         font=("arial",14,"bold"))
        self.Label_Filtro.place(x=18.5+210+45,y=0)
        # criando ComboBox de filtro para busca de itens
        self.Filtro_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values=['','ID','Vencidos','Vence em','Vence depois de','Identif.','Código','Resp.','Validade','Volume'] ,
                                        width=130, height=35, font=('arial',14,'bold'),corner_radius=8)
        self.Filtro_entry.place(x=18+210+45,y=25)
        
        
        # criando Label para entry Identificação
        self.Label_Ident = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Identificador:',
                                        font=("arial",14,"bold"))
        self.Label_Ident.place(x=18.5,y=50+40)
        # criando entry para Identificação
        self.Identficador_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values=['','EC','PT','MP','GR'] ,
                                        width=105, height=35, font=('arial',14,'bold'),corner_radius=8)
        self.Identficador_entry.place(x=18.5,y=50+65)
        
        
        # criando Label da entry para IDs
        self.Label_ID_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='ID:', font=("arial",14,"bold"))
        self.Label_ID_entry.place(x=18.5+115,y=50+40)
        # criando entry para IDs
        self.ID_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                        width=100, height=35, font=('arial',14))
        self.ID_entry.place(x=18+116,y=50+65)
        
        
        # criando Label da entry para Volume
        self.Label_Volume_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Volume:',font=("arial",14,"bold"))
        self.Label_Volume_entry.place(x=19+135+115+17-40,y=50+40)
        # criando entry para Volume
        self.Volume_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),
                                        values=['','Balde 3,6 L','Balde 5 L','Balde 10 L','Balde 18 L','Bombona 20 L','Bombona 50 L','Pote 500 mL','Frasco 250 mL', 'Caixa'],
                                        width=158, height=35, font=('arial',14,'bold'),corner_radius=8 )
        self.Volume_entry.place(x=17+135+115+17-40,y=50+65)
        
        
        #variável para inserir como lista de Responsáveeis  no combobox Responsável
        self.Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
        # criando Label da entry para Responsáveis
        self.Label_Responsavel_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Responsável:',
                                                    font=("arial",14,"bold"))
        self.Label_Responsavel_entry.place(x=18.5,y=50+40+63)
        # criando entry para Responsáveis
        self.Responsavel_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),
                                        values = self.Responsáveis,
                                        width=235, height=35, font=('arial',14),corner_radius=8 )
        self.Responsavel_entry.place(x=18,y=50+65+63)
        
        #variável para inserir códigos com lista no combobox códigos
        self.códigos = tuple_to_list(fetch_itens(Table_Códigos))
        # criando Label da entry para Códigos
        self.Label_Codigo_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Código:', 
                                               font=("arial",14,"bold"))
        self.Label_Codigo_entry.place(x=18.5+265-15,y=50+40+63)
        # criando Label da entry para Códigos
        self.Codigo_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values = self.códigos , 
                                        width=136, height=35, font=('arial',14))
        self.Codigo_entry.place(x=18+265-17,y=50+65+63)
        
        
        # criando Label da entry para Observações
        self.Label_OBS_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='OBS:', font=("arial",14,"bold"))
        self.Label_OBS_entry.place(x=18.5,y=50+40+63+63)
        # criando entry para Observações
        self.OBS_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                      width=217.5, height=35, font=('arial',14))
        self.OBS_entry.place(x=18,y=50+65+63+60)
        
        
        # criando Label da entry para Validade
        self.Label_Validade_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Validade:', font=("arial",15,"bold"))
        self.Label_Validade_entry.place(x=18.5+215+67-55,y=50+40+63+63)
        # criando entry para Validade
        self.Validade_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), placeholder_text= 'dd/mm/AAAA',
                                        placeholder_text_color='#333', width=115, height=35, font=('arial',14))
        self.Validade_entry.place(x=18+215+67-51.5,y=50+65+63+60)
        
        
        #criando função para pegar data do calendário
        def take_date():
            self.Validade_entry.delete(0,END)
            self.Validade_entry.insert(0, f'{self.Calen_Validade.get_date()}')
            
        #criando botão para pegar data do calendário
        self.Validade_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='🗓',command = take_date,text_color = 'black',#command =, 
                                font=("arial",18), height=35, width=35,corner_radius=8, #border_color='silver',
                                border_width=1.5, fg_color = 'silver', hover_color ='white'  ) 
                               #, border_color='silver')
        self.Validade_Button.place(x=18+215+12+120.5,y=50+65+63+60)
        
        #criando função para limpar tudo
        def clear_all():
            self.Identficador_entry.set('')
            self.ID_entry.delete(0,END)
            self.Codigo_entry.set('')
            self.Validade_entry.delete(0,END)
            self.Responsavel_entry.set('')
            self.Volume_entry.set('')
            self.OBS_entry.delete(0,END)
            self.Filtro_entry.set('')
            self.Busca_entry.delete(0,END)
            self.TREEVIEW.selection_remove(self.TREEVIEW.focus())
            add_to_TREEVIEW()
        
        #criando função limpar dados da TREEVIEW
        def clear(*clicked):
            
            if clicked:
                self.TREEVIEW.selection_remove(self.TREEVIEW.focus())
            self.Identficador_entry.set('')
            self.ID_entry.delete(0,END)
            self.Codigo_entry.set('')
            self.Validade_entry.delete(0,END)
            self.Responsavel_entry.set('')
            self.Volume_entry.set('')
            self.OBS_entry.delete(0,END)
            

        #criando função para mostrar dados selecionados
        def display_data(event):
            
            selected_item = self.TREEVIEW.focus()
            
            if selected_item:
                row = self.TREEVIEW.item(selected_item)['values']
                clear()
                self.Identficador_entry.set(row[0])
                self.ID_entry.insert(0,row[1])
                self.Codigo_entry.set(row[2])
                self.Validade_entry.insert(0,row[3])
                self.Responsavel_entry.set(row[4])
                self.Volume_entry.set(row[5])
                self.OBS_entry.insert(0, fetch_OBS(row[1])[0])
            else:
                pass
        
        #criando função para adicionar a TREEVIEW
        def add_to_TREEVIEW():
            dict_Filtro = {'ID':'Id',
                           'Identif.':'Identificador',
                           'Código':'Código',
                           'Resp.':'Responsável',
                           'Validade':'Validade',
                           'Volume':'Volume'}
            
            if self.Busca_entry.get().upper() == 'VENCIDOS' or self.Filtro_entry.get() == 'Vencidos':
                itens = lista_vencidos()
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)
            
            elif self.Filtro_entry.get() == 'Vence em':
                itens = lista_vencidos_em(int(self.Busca_entry.get().replace('dias','').strip()))
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)
            
            elif self.Filtro_entry.get() == 'Vence depois de':
                itens = lista_vencidos_daqui(int(self.Busca_entry.get().replace('dias','').strip()))
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)
            
            elif self.Filtro_entry.get() == '' or self.Busca_entry.get() == '':
                itens = fetch_itens(Table_Stock)
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                
            
            elif self.Filtro_entry.get() == 'Resp.':
                itens = buscar(dict_Filtro[self.Filtro_entry.get()], self.Busca_entry.get().strip().title())
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)    
            else:     
                itens = buscar(dict_Filtro[self.Filtro_entry.get()], self.Busca_entry.get().strip().upper())
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)

        #criando função para inserção de itens
        def INSERIR():
            
            Lista = ['EC','PT','MP','GR']
            
            Identificador = self.Identficador_entry.get()
            ID = self.ID_entry.get().strip().replace(' ', '')
            Responsável = self.Responsavel_entry.get().title().strip()
            Código = self.Codigo_entry.get().upper().strip()
            Validade = self.Validade_entry.get().strip()
            Volume = self.Volume_entry.get().strip()
            OBS = self.OBS_entry.get().strip()
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao inserir ID','Por favor, insira um número \ninteiro válido de 5 a 8 dígitos \nno campo ID. ')
            
            elif id_exists(ID):
                messagebox.showerror('Erro ao inserir ID',f'Não é possível inserir o \nitem pois o ID {ID} \njá foi cadastrado.\n\nPor favor, insira um ID \nainda não utilizado.')
            
            elif ( (len(Validade.split('/')[0])!=2 or Validade.split('/')[0].isdigit == False) or
                   (len(Validade.split('/')[1])!=2 or Validade.split('/')[1].isdigit == False) or
                   (len(Validade.split('/')[2])!=4 or Validade.split('/')[2].isdigit == False) ):
                messagebox.showerror('Erro ao inserir a Validade','Por favor, insira a data de validade \nno padrão dd/mm/AAAA')
            
            elif Identificador not in Lista:
                messagebox.showerror('Erro ao inserir dados', 'Por favor, selecione um \nidentificador válido.')      
            
            elif Responsável == '' or Código == '' or Volume == '':
                messagebox.showerror('Erro ao inserir dados', 'Por favor, preencha todos \nnos campos pertinentes')
                
            else:
                
                insert_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS)
                
                #adicionando novos Códigos a lista de Códigos
                if Código in self.códigos:
                    pass
                else:
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                
                #adicionando novos Nomes a lista de responsáveis
                if Responsável in self.Responsáveis:
                    pass
                else:
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)

                add_to_TREEVIEW()
                messagebox.showinfo('Inserção bem sucedida!',f'O item {ID} foi inserido com sucesso!')
                    
        
        #criando botão para INSERIR dados
        self.INSERIR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='➕ Inserir',command = INSERIR , 
                                font=("arial",12), height=30, width=65,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#080278')
        self.INSERIR_Button.place(x=18+215+12+117+58,y=50+65+63+54)
        

        #criando função para deletar itens
        def DELETAR():
            
            ID = self.ID_entry.get()
            
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao deletar ID','Por favor, selecione \no item que deseja deletar.\n\nOu, insira um número inteiro \nválido de 5 a 8 dígitos \nno campo ID.')
            
            elif id_exists(ID) == False:
                messagebox.showerror('Erro ao deletar ID',f'Não é possível deletar o \nitem pois o ID {ID} \nainda não foi cadastrado.\n\nPor favor, tente deletar apenas \nitens existentes.')
            else:
                resposta = messagebox.askyesno('Atenção ao deletar', f'Tem certeza que deseja\ndeletar o item (ID: {ID})?')
                
                if resposta == 1:
                    delete_itens(ID)
                    add_to_TREEVIEW()
                    messagebox.showinfo('Exclusão bem sucedida!',f'Item {ID} deletado com sucesso.')
                    
                else:
                    pass
            
        #criando botão para DELETAR dados
        self.DELETAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✖️ Deletar',command = DELETAR, 
                                font=("arial",12), height=30, width=65,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#a60202', hover_color ='#ba2929' )
        self.DELETAR_Button.place(x=18+215+12+117+60+166,y=50+65+63+54)
        
        
        #criando função para atualização de dados
        def ATUALIZAR():
            
            Lista = ['EC','PT','MP','GR']
            
            Identificador = self.Identficador_entry.get()
            ID = self.ID_entry.get().strip().replace(' ', '')
            Responsável = self.Responsavel_entry.get().title().strip()
            Código = self.Codigo_entry.get().upper().strip()
            Validade = self.Validade_entry.get().strip()
            Volume = self.Volume_entry.get().strip()
            OBS = self.OBS_entry.get().strip()
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao atualizar ID','Por favor, selecione \no item que deseja atualizar.\n\nOu, insira o ID que deseja\natualizar no campo ID. ')
            
            elif id_exists(ID) == False:
                messagebox.showerror('Erro ao atualizar ID',f'Não é possível atualizar o \nitem pois o ID {ID} \nainda não foi cadastrado.\n\nPor favor, atualize apenas itens \nexistentes.')
            
            elif ( (len(Validade.split('/')[0])!=2 or Validade.split('/')[0].isdigit == False) or
                   (len(Validade.split('/')[1])!=2 or Validade.split('/')[1].isdigit == False) or
                   (len(Validade.split('/')[2])!=4 or Validade.split('/')[2].isdigit == False) ):
                messagebox.showerror('Erro ao inserir a Validade','Por favor, insira a data de validade \nno padrão dd/mm/AAAA')
                
            elif Identificador not in Lista:
                messagebox.showerror('Erro ao inserir dados', 'Por favor, selecione um \nidentificador válido.')      
            
            elif Responsável == '' or Código == '' or Volume == '':
                messagebox.showerror('Erro ao inserir dados', 'Por favor, preencha todos \nos campos pertinentes')
                
            else:
                  
                update_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS)
                
                #adicionando novos Códigos a lista de Códigos
                if Código in self.códigos:
                    pass
                else:
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                
                #adicionando novos Nomes a lista de responsáveis
                if Responsável in self.Responsáveis:
                    pass
                else:
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)

                add_to_TREEVIEW()
                messagebox.showinfo('Atualização bem sucedida!',f'O item {ID} foi atualizado com sucesso!')
              
                
        
        #criando botão para ATUALIZAR dados
        self.ATUALIZAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✏ Atualizar',command = ATUALIZAR, 
                                font=("arial",12), height=30, width=73,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#02783b', hover_color ='#179c57'  )
        self.ATUALIZAR_Button.place(x=18+215+12+117+60+77,y=50+65+63+54)
        
        #criando botão limpar
        self.LIMPAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✨Limpar',text_color='black',command = clear_all ,  
                                font=("arial",11), height=20, width=30,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#e6a902', hover_color ='#b88702'  )#fg_color = 'silver', hover_color ='white')
        self.LIMPAR_Button.place(x=18,y=65)
        
        #criando função gatilho para botão de busca
        def busca_button():
            
            lista_filtro = ['ID','Vencidos','Vence em','Vence depois de','Identif.','Código','Resp.','Validade','Volume']
            
            if self.Busca_entry.get().upper() == 'VENCIDOS' or self.Filtro_entry.get() == 'Vencidos':
                resultado = add_to_TREEVIEW()
                messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} \nitens vencidos.')
                
            elif self.Filtro_entry.get() == 'Vence em':
                if self.Busca_entry.get().replace('dias','').strip().isnumeric() == True: 
                    busca = self.Busca_entry.get().replace('dias','').strip()
                    resultado = add_to_TREEVIEW()
                    if resultado > 1:
                        messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} \nitens que vencerão nos\npróximos {busca} dias.')
                    elif resultado == 0:
                        messagebox.showinfo('Resultado da busca', 'Nenhum item foi encontrado.')
                    else:
                        messagebox.showinfo('Resultado da busca', f'Foi encontrado apenas 1 \nitem que vencerá nos\npróximos {busca} dias.')
                
                else:
                    messagebox.showerror('Erro ao buscar','Por favor, degite um número de dias\nválido para realizar a busca.')
            
            elif self.Filtro_entry.get() == 'Vence depois de':
                if self.Busca_entry.get().replace('dias','').strip().isnumeric() == True: 
                    busca = self.Busca_entry.get().replace('dias','').strip()
                    resultado = add_to_TREEVIEW()
                    if resultado > 1:
                        messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} \nitens que vencerão\ndaqui {busca} dias.')
                    elif resultado == 0:
                        messagebox.showinfo('Resultado da busca', 'Nenhum item foi encontrado.')
                    else:
                        messagebox.showinfo('Resultado da busca', f'Foi encontrado apenas 1 \nitem que vencerá\ndaqui {busca} dias.')
                
                else:
                    messagebox.showerror('Erro ao buscar','Por favor, degite um número de dias\nválido para realizar a busca.')
            
            elif self.Filtro_entry.get() in lista_filtro and self.Busca_entry.get() != '':
                resultado = add_to_TREEVIEW()
                
                if resultado != 0 and self.Filtro_entry.get() != 'ID':
                    if resultado != 1:
                        messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} itens.')
                    else:
                        messagebox.showinfo('Resultado da busca', f'Apenas 1 item foi encontrado.')
                        
                elif resultado != 0 and self.Filtro_entry.get() == 'ID':  
                    pass
                
                else:
                    messagebox.showinfo('Resultado da busca', 'Nenhum item foi encontrado.')
                    
            else:
                messagebox.showinfo('Busca vazia', 'Por favor, digite sua pesquisa\nna barra de busca e selecione\num dos filtros listados.')
        
        # criando botão de gatilho para  buscar de itens
        def take_entry_Busca():
            return self.Busca_entry.get()
        self.Busca_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='🔍',text_color = 'black',command = busca_button , 
                                font=("arial",18), height=35, width=35,corner_radius=8, border_color='silver',
                                border_width=1.5, fg_color = 'silver', hover_color ='white'  ) 
        self.Busca_Button.place(x=18+208,y=25)
            
        ####  CRIANDO TREEVIEW PARA ABA "Controle de Dados"  #################################################
        
        #criando frame da treeview
        self.TREEVIEW_Frame = CTkFrame(self.tabview.tab("Controle de Dados"))
        self.TREEVIEW_Frame.place(x=18,y=285)
        
        #criando um estilo para Treeview
        self.style = Style(self.TREEVIEW_Frame)
        
        self.style.theme_use('clam')
        self.style.configure('Treeview', font = ("arial",9),foreground='black',background='silver',fieldbackround='black')
        self.style.map('Treeview', background=[('selected','#012563')])#'#036491')])
        
        #criando scrollbar para treeview
        self.TREEVIEW_scrollbar = Scrollbar(self.TREEVIEW_Frame)
        self.TREEVIEW_scrollbar.pack(side=RIGHT,fill=Y )
        
        # #criando Treeview
        self.TREEVIEW = Treeview(self.TREEVIEW_Frame,height=7,yscrollcommand=self.TREEVIEW_scrollbar.set )
        self.TREEVIEW.pack()#place(x=18,y=285)
        # #ativando o click da scrollbar
        self.TREEVIEW_scrollbar.configure(command=self.TREEVIEW.yview)
        
        #criando colunas
        self.TREEVIEW['columns'] = ('Identif.','ID','Código','Validade','Responsável','Volume')
        self.TREEVIEW.column('#0', width=0, stretch=NO)
        self.TREEVIEW.column('Identif.',anchor=CENTER, width=70)
        self.TREEVIEW.column('ID',anchor=CENTER, width=102)
        self.TREEVIEW.column('Código',anchor=CENTER, width=110)
        self.TREEVIEW.column('Responsável',anchor=CENTER, width=132)
        self.TREEVIEW.column('Validade',anchor=CENTER, width=112)
        self.TREEVIEW.column('Volume',anchor=CENTER, width=101)
        
        #inserindo nome das colunas
        self.TREEVIEW.heading('Identif.', text='Identif.')
        self.TREEVIEW.heading('ID', text='ID')
        self.TREEVIEW.heading('Código', text='Código')
        self.TREEVIEW.heading('Responsável', text='Responsável')
        self.TREEVIEW.heading('Validade', text='Validade')
        self.TREEVIEW.heading('Volume', text='Volume')
        
        
        self.TREEVIEW.bind('<ButtonRelease>', display_data)
        
        add_to_TREEVIEW()
        
        ##### CRIANDO ABA DE "Correções" #################################################################
        
        #criando label de aviso
        self.Aviso_Label = ctk.CTkLabel(self.tabview.tab("Correções"), text = """*Use apenas para corrigir códigos ou responsáveis com erros de digitação.\n*Não use para alterar itens com cadastro incorreto!""",
                                        font=("arial",13), justify = "center")
        self.Aviso_Label.pack(pady=5)
        
        #criando frame para aba alterações
        self.Alteração_Frame = ctk.CTkFrame(self.tabview.tab("Correções"),
                                            width=700*0.5, height=510*0.75, border_color='grey',
                                            border_width = 2, fg_color='#f2f2f2')
        self.Alteração_Frame.pack(pady=10)
        
      
            
        #criando Label para correção de códigos velhos
        self.Label_Alteração_código = ctk.CTkLabel(self.Alteração_Frame, text='Correção de Códigos', text_color='#4e4f4f',
                                               font=("arial",16,"bold"))
        self.Label_Alteração_código.place(x = 30, y =17+5 )                                       
        self.Label_combo_código = ctk.CTkLabel(self.Alteração_Frame, text='Velho:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_código.place(x=30,y=50)
        #criando combobox para correção de códigos velhos
        self.combo_código = ctk.CTkComboBox(self.Alteração_Frame,values = self.códigos , 
                                        width=150, height=35, font=('arial',14))
        self.combo_código.place(x=29.5,y=50+25)
        
        #criando Label Novo para correção de códigos novos
        self.Label_combo_código = ctk.CTkLabel(self.Alteração_Frame, text='Novo:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_código.place(x=30+155,y=50)
        #criando combobox para correção de códigos novos
        self.entry_código_novo = ctk.CTkEntry(self.Alteração_Frame, 
                                        width=135, height=35, font=('arial',14))
        self.entry_código_novo.place(x=29.5+155,y=50+25)
        
        
        #criando Label para correção de responsáveis velhos
        self.Label_Alteração_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Correção de Responsáveis', text_color='#4e4f4f',
                                               font=("arial",16,"bold"))
        self.Label_Alteração_Resp.place(x = 30, y =17+130 )                                       
        self.Label_combo_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Velho:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_Resp.place(x=30,y=50+125)
        #criando combobox para correção de responsáveis velhos
        self.combo_Resp = ctk.CTkComboBox(self.Alteração_Frame,values = self.Responsáveis ,
                                        width=150, height=35, font=('arial',14))
        self.combo_Resp.place(x=29.5,y=50+25+125)
        
        #criando Label da combobox para correção de responsáveis novos
        self.Label_combo_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Novo:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_Resp.place(x=30+155,y=50+125)
        #criando combobox para correção de responsáveis novos
        self.entry_Resp_novo = ctk.CTkEntry(self.Alteração_Frame, 
                                        width=135, height=35, font=('arial',14))
        self.entry_Resp_novo.place(x=29.5+155,y=50+25+125)
      
    
        #criando função para atualização de dados da aba correção
        def CORRIGIR_Atualizar():
            
            Código_wrong = self.combo_código.get()
            Código_right = self.entry_código_novo.get().upper().strip()
            
            Resp_wrong = self.combo_Resp.get()
            Resp_right = self.entry_Resp_novo.get().title().strip()
            
            
            
            if Código_wrong == ''  and Código_right == '' and Resp_wrong == '' and Resp_right == '':
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
                  
            elif Código_wrong != '' and Resp_wrong != '':
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas\numa categoria por vez.')
                
            #condição código correto
            elif Código_wrong != ''  and Código_right != '' and Resp_wrong == '' and Resp_right == '':
                
                if Código_wrong == Código_right:
                    
                    messagebox.showerror('Erro ao Corrigir','Não é possível atualizar parâmetros\npara o mesmo valor.')
                    
                else:
                
                    if codigo_exists(Código_wrong) == True:
                        
                        resposta = messagebox.askyesno('Atenção ao atualizar', f'Tem certeza que deseja\natualizar o código {Código_wrong} \npara {Código_right}?\n\nA atualização deve ser feita apenas\npara parâmetros que foram\ncadastrados com erro de digitação.\n\nNão use para corrigir itens\ncadastrados de forma incorreta!')
                        
                        if resposta == 1:
                            data_correction(Código_wrong, Código_right, 'Códigos', 'Atualizar')
                            
                            add_to_TREEVIEW()
                            
                            followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                            self.Codigo_entry.configure(values = followup_Códigos)
                            self.combo_código.configure(values = followup_Códigos)
                            
                            messagebox.showinfo('Atualização bem sucedida!',f'O código {Código_wrong} foi atualizado \npara {Código_right} com sucesso!')
                        
                        else:
                            pass
                        
                    else:
                        messagebox.showerror('Erro ao Corrigir','Por favor, selecione um código \njá cadastrado.')
            
                
            #condição responsável correto
            elif Código_wrong == ''  and Código_right == '' and Resp_wrong != '' and Resp_right != '':
                
                if Resp_wrong == Resp_right:
                    
                    messagebox.showerror('Erro ao Corrigir','Não é possível atualizar parâmetros\npara o mesmo valor.')
                    
                else:
                
                    if resp_exists(Resp_wrong) == True:
                        
                        resposta = messagebox.askyesno('Atenção ao atualizar', f'Tem certeza que deseja\natualizar o responsável {Resp_wrong} \npara {Resp_right}?\n\nA atualização deve ser feita apenas \npara parâmetros que foram \ncadastrados com erro de digitação.\n\nNão use para corrigir itens\ncadastrados de forma incorreta!')
                        
                        if resposta == 1:
                          
                            data_correction(Resp_wrong, Resp_right, 'Responsáveis', 'Atualizar')
                            
                            add_to_TREEVIEW()
                            
                            followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                            self.Responsavel_entry.configure(values = followup_Responsáveis)
                            self.combo_Resp.configure(values = followup_Responsáveis)
                            
                            messagebox.showinfo('Atualização bem sucedida!',f'O responsável {Resp_wrong} foi atualizado \npara {Resp_right} com sucesso!')
                        
                        else:
                            pass
                        
                    else:
                        messagebox.showerror('Erro ao Corrigir','Por favor, selecione um responsável \njá cadastrado.')
                        
            # elif Código_right != '' and Resp_wrong != '' and Resp_right != '':
            
            elif Resp_wrong == '' and Resp_right == '' and Código_wrong != ''  and Código_right == '' :
                
                messagebox.showerror('Erro ao Corrigir','Não é possível cadastrar um\nparâmetro vazio.')
            
            elif Resp_wrong == '' and Resp_right == '' and Código_wrong == ''  and Código_right != '' :
                
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
            
            elif Resp_wrong != '' and Resp_right == '' and Código_wrong == ''  and Código_right == '' :
                
                messagebox.showerror('Erro ao Corrigir','Não é possível cadastrar um\nparâmetro vazio.')
            
            elif Resp_wrong == '' and Resp_right != '' and Código_wrong == ''  and Código_right == '' :
                
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
    
            else:
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas\numa categoria por vez.')
                
        
        #criando função para exclusão de dados da aba correção
        def CORRIGIR_Deletar():
            
            Código_wrong = self.combo_código.get()
            Código_right = self.entry_código_novo.get().upper().strip()
            
            Resp_wrong = self.combo_Resp.get()
            Resp_right = self.entry_Resp_novo.get().title().strip()
            
            
            
            if Código_wrong == '' and Resp_wrong == '':
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
                  
            elif Código_wrong != '' and Resp_wrong != '':
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas\numa categoria por vez.')
                  
            #condição código correto
            elif Código_wrong != '':
                
                if codigo_exists(Código_wrong) == True:
                    
                    resposta = messagebox.askyesno('Atenção ao deletar', f'Tem certeza que deseja\ndeletar o código {Código_wrong}?\n\nA exclusão deve ser feita apenas para\nparâmetros que foram cadastrados\ncom erro de digitação.')
                    
                    if resposta == 1:
                    
                        data_correction(Código_wrong, Código_right, 'Códigos', 'Deletar')
                        
                        add_to_TREEVIEW()
                        
                        followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                        self.Codigo_entry.configure(values = followup_Códigos)
                        self.combo_código.configure(values = followup_Códigos)
                        
                        messagebox.showinfo('Exclusão bem sucedida!',f'O item {Código_wrong} foi excluído com sucesso!')
                    
                    else:
                        pass
                
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um código \njá cadastrado.')
                
            #condição responsável correto
            elif Resp_wrong != '':
                
                if resp_exists(Resp_wrong) == True:
                    
                    resposta = messagebox.askyesno('Atenção ao deletar', f'Tem certeza que deseja\ndeletar o responsável {Resp_wrong}?\n\nA exclusão deve ser feita apenas para\nparâmetros que foram cadastrados\ncom erro de digitação.')
                    
                    if resposta == 1:
                    
                        data_correction(Resp_wrong, Resp_right, 'Responsáveis', 'Deletar')
                        
                        add_to_TREEVIEW()
                        
                        followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                        self.Responsavel_entry.configure(values = followup_Responsáveis)
                        self.combo_Resp.configure(values = followup_Responsáveis)
                        
                        messagebox.showinfo('Exclusão bem sucedida!',f'O item {Resp_wrong} foi excluído com sucesso!')
                    
                    else:
                        pass
                    
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um responsável \njá cadastrado.')
            
            else:
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas uma \ncategoria por vez.')
                
        #criando botão para ATUALIZAR dados
        self.ATUALIZAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='⬆ Atualizar',command = CORRIGIR_Atualizar , 
                                font=("arial",19), height=35, width=110,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#02783b', hover_color ='#179c57'  )
        self.ATUALIZAR_Button_correções.place(x=60,y=50+65+63+54+35)
        
          
        #criando botão deletar na aba correções
        self.DELETAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='❌ Deletar',command = CORRIGIR_Deletar , 
                                font=("arial",19), height=35, width=100,corner_radius=8, border_width=1.5 ,
                                fg_color = '#a60202', hover_color ='#ba2929' )
        self.DELETAR_Button_correções.place(x=185,y=50+65+63+54+35)
        
        
        #criando função para limpar aba correções
        def clear_corrections():
            
            self.combo_código.set('')
            self.entry_código_novo.delete(0,END)
        
            self.combo_Resp.set('')
            self.entry_Resp_novo.delete(0,END)
            
        
        
        #criando botão limpar
        self.LIMPAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='✨Limpar',text_color='black',command = clear_corrections ,  
                                font=("arial",17), height=30, width=50,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#e6a902', hover_color ='#b88702'  )#fg_color = 'silver', hover_color ='white')
        self.LIMPAR_Button_correções.place(x=130,y=330)   
        
        
        ##### CRIANDO ABA DE "Relatório" #################################################################
        
        #Label aba relatório
        self.Relat_Label = ctk.CTkLabel(self.tabview.tab('Relatório'), text='Relatório | Indicadores',
                                        font=("arial",30))
        self.Relat_Label.place(x=200,y=20)
        
        #criando frame para exibir relatório
        self.Relat_frame = ctk.CTkScrollableFrame(self.tabview.tab('Relatório') , width=600, height=220,
                                                  border_width=1.5, fg_color='#f2f2f2' )
        self.Relat_frame.place(x=30,y=80)
        
        #função para mostrar painel de indicadores
        def display_indicators():
            
            global dict_Var_Resp
            global dict_Data_Resp
            
            itens = tuple_to_list(fetch_itens(Table_Resp))
            itens.pop(0)
            
            dict_Var_Resp = {}
            dict_Data_Resp = {}
            
            if (len(itens)%3)==0:
                r = int(len(itens)/3)
            else:
                r = (len(itens)//3)+1
            
            count = 0
            n = 0
            valor = 3
            for j in range(0,r):
                count1 = 0
                
                if j == r-1 and len(itens)%3 !=0 :
                    valor = len(itens)%3
                for k in range(0,valor):
                    
                    data_list1 = busca_relatório(itens[n])
                    vencidos = N_vencidos(data_list1, 1)
                    vencidos15 = N_vencidos(data_list1, 0)
                    itens_Ok = N_vencidos(data_list1, 2)
                    
                    dict_Data_Resp[itens[n]] = [vencidos,vencidos15,itens_Ok]
                    
                    
                    if len(vencidos) != 0:
                    
                        self.Resp_Frame = ctk.CTkFrame(self.Relat_frame,width=185,height=110, border_width=1.5)#, fg_color='#ff0303' )
                        self.Resp_Frame.grid(row=count,column=count1, padx = 8, pady = 8)
                        
                        self.Resp_Frame_name = ctk.CTkFrame(self.Resp_Frame,width=170,height=35.3,border_width=1.5, fg_color='#b50404' )
                        self.Resp_Frame_name.place(x=7,y=5)
                        
                        self.check_var = ctk.BooleanVar(value=False)
                        self.Resp_Frame_Check = ctk.CTkCheckBox(self.Resp_Frame_name , text=f' {itens[n]}',font=("arial",17,'bold'), bg_color='#b50404',
                                                                border_color='white',corner_radius= 20, text_color='white',
                                                                hover_color = 'grey',variable=self.check_var,onvalue=True,offvalue=False,
                                                                checkbox_width=20,checkbox_height=20)
                        self.Resp_Frame_Check.place(x=7,y=5)
                        
                        dict_Var_Resp[itens[n]] = (self.check_var,self.Resp_Frame_Check,'Vencidos')
                        
                        self.N_itens = ctk.CTkLabel(self.Resp_Frame , text=f'Nº de itens: {len(data_list1)}',font=("arial",12))
                        self.N_itens.place(x=10,y=40)
                        
                        self.N_vencidos = ctk.CTkLabel(self.Resp_Frame , text=f'Vencidos: {len(vencidos)}',font=("arial",12,'bold'))
                        self.N_vencidos.place(x=10,y=60)
                        
                        self.N_vencidos15 = ctk.CTkLabel(self.Resp_Frame , text=f'Vence em 15 dias: {len(vencidos15)}',font=("arial",12,'bold'))
                        self.N_vencidos15.place(x=10,y=80)
                        
                    elif len(vencidos15) != 0:
                        
                        self.Resp_Frame = ctk.CTkFrame(self.Relat_frame,width=185,height=110, border_width=1.5)#, fg_color='#ff0303' )
                        self.Resp_Frame.grid(row=count,column=count1, padx = 8, pady = 8)
                        
                        self.Resp_Frame_name = ctk.CTkFrame(self.Resp_Frame,width=170,height=35.3,border_width=1.5, fg_color='#c29502' )
                        self.Resp_Frame_name.place(x=7,y=5)
                        
                        self.check_var = ctk.BooleanVar(value=False)
                        self.Resp_Frame_Check = ctk.CTkCheckBox(self.Resp_Frame_name , text=f' {itens[n]}',font=("arial",17,'bold'), bg_color='#c29502',
                                                                border_color='white',corner_radius= 20, text_color='white',
                                                                hover_color = 'grey',variable=self.check_var,onvalue=True,offvalue=False,
                                                                checkbox_width=20,checkbox_height=20)
                        self.Resp_Frame_Check.place(x=7,y=5)
                        
                        dict_Var_Resp[itens[n]] = (self.check_var,self.Resp_Frame_Check,'Vence_em_15')
                        
                        self.N_itens = ctk.CTkLabel(self.Resp_Frame , text=f'Nº de itens: {len(data_list1)}',font=("arial",12))
                        self.N_itens.place(x=10,y=40)
                        
                        self.N_vencidos = ctk.CTkLabel(self.Resp_Frame , text=f'Vencidos: {len(vencidos)}',font=("arial",12,'bold'))
                        self.N_vencidos.place(x=10,y=60)
                        
                        self.N_vencidos15 = ctk.CTkLabel(self.Resp_Frame , text=f'Vence em 15 dias: {len(vencidos15)}',font=("arial",12,'bold'))
                        self.N_vencidos15.place(x=10,y=80)
                        
                    else:
                        
                        self.Resp_Frame = ctk.CTkFrame(self.Relat_frame,width=185,height=110, border_width=1.5)#, fg_color='#ff0303' )
                        self.Resp_Frame.grid(row=count,column=count1, padx = 8, pady = 8)
                        
                        self.Resp_Frame_name = ctk.CTkFrame(self.Resp_Frame,width=170,height=35.3,border_width=1.5, fg_color='#016634' )
                        self.Resp_Frame_name.place(x=7,y=5)
                        
                        self.check_var = ctk.BooleanVar(value=False)
                        self.Resp_Frame_Check = ctk.CTkCheckBox(self.Resp_Frame_name , text=f' {itens[n]}',font=("arial",17,'bold'), bg_color='#016634',
                                                                border_color='white',corner_radius= 20, text_color='white',
                                                                hover_color = 'grey',variable=self.check_var,onvalue=True,offvalue=False,
                                                                checkbox_width=20,checkbox_height=20)
                        self.Resp_Frame_Check.place(x=7,y=5)
                        
                        dict_Var_Resp[itens[n]] = (self.check_var,self.Resp_Frame_Check,'Ok')
                        
                        self.N_itens = ctk.CTkLabel(self.Resp_Frame , text=f'Nº de itens: {len(data_list1)}',font=("arial",12))
                        self.N_itens.place(x=10,y=40)
                        
                        self.N_vencidos = ctk.CTkLabel(self.Resp_Frame , text=f'Vencidos: {len(vencidos)}',font=("arial",12,'bold'))
                        self.N_vencidos.place(x=10,y=60)
                        
                        self.N_vencidos15 = ctk.CTkLabel(self.Resp_Frame , text=f'Vence em 15 dias: {len(vencidos15)}',font=("arial",12,'bold'))
                        self.N_vencidos15.place(x=10,y=80)
                        
                    count1 += 1
                    n += 1
                count += 1
            
            
        #Criando botão para refresh♻️↻🔄📦📥📬
        self.refresh_button_1 = ctk.CTkButton(self.tabview.tab('Relatório'),text='',command = display_indicators() , 
                                font=("helvitica",12,'bold'), height=25, width=30,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = 'grey', hover_color ='#a1a1a1')
        self.refresh_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='Refresh',command = display_indicators , 
                                font=("helvitica",12,'bold'), height=25, width=30,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = 'grey', hover_color ='#a1a1a1')
        self.refresh_button.place(x=578,y=52)
        
        
        #criando função para selecionar apenas itens vencidos
        def select_vencidos():
            
            for value in dict_Var_Resp.values():
                var,my_check,status = value
                if status == 'Vencidos':
                    my_check.toggle()
        
        #criando botão para selecionar itens vencidos ❕✅✔️
        self.select_vencidos_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='❕ Vencidos',command = select_vencidos , 
                                font=("helvitica",12,'bold'), height=25, width=80,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = '#b50404', hover_color ='#e30202')
        self.select_vencidos_button.place(x=32,y=235+85)
        
        #criando função para selecionar apenas itens que vencem dentro de 15 dias
        def select_vencidos15():
            
            for value in dict_Var_Resp.values():
                var,my_check,status = value
                if status == 'Vence_em_15':
                    my_check.toggle()
                    
        #criando botão para selecionar itens que vencem dentro de 15 dias ❕✅✔️
        self.select_vencidos15_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='⚠ 15 dias',command = select_vencidos15 , 
                                font=("helvitica",12,'bold'), height=25, width=80,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = '#ab8903', hover_color ='#e3b602')
        self.select_vencidos15_button.place(x=32+90,y=235+85)
        
        #criando função para selecionar apenas itens que vencem dentro de 15 dias
        def select_Oks():
            
            for value in dict_Var_Resp.values():
                var,my_check,status = value
                if status == 'Ok':
                    my_check.toggle()
                    
        #criando botão para selecionar itens Ok ✔️
        self.select_Ok_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='✔️ Ok  ',command = select_Oks , 
                                font=("helvitica",12,'bold'), height=25, width=80,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = '#016634', hover_color ='#02993c')
        self.select_Ok_button.place(x=32+90+88,y=235+85)
        
        #criando função para limpar itens selecionados
        def clear_checked_itens():
            
            for value in dict_Var_Resp.values():
                var,my_check,status = value
                my_check.deselect()
                
            self.trazer_todos_check.deselect()
            self.trazer_vence15_check.deselect()
        
        # criando botão para limpar itens do relatório selecionados
        self.limpar_frames_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='✨Limpar',command = clear_checked_itens , 
                                font=("helvitica",12), height=25, width=30,corner_radius=8,border_width=1.5 ,text_color='black',
                                fg_color = '#e6a902', hover_color ='#b88702')
        self.limpar_frames_button.place(x=35,y=52)
        
        #criando frame para checkbox trazer_vence15_check
        self.trazer_vence15_Frame = ctk.CTkFrame(self.tabview.tab('Relatório'),width=350,height=29,border_width=1.5, fg_color='#f2f2f2' )
        self.trazer_vence15_Frame.place(x=32+90+88+94,y=235+85)
        
        #criando checkbox para trazer da base de dados itens que vencem em 15 dias
        self.check_var_vence15 = ctk.BooleanVar(value=False)
        self.trazer_vence15_check = ctk.CTkCheckBox(self.trazer_vence15_Frame , text=' Trazer dados de itens que vecem em 15 dias',font=("Helvitica",14),
                                                border_color='grey', text_color='black',corner_radius=1,border_width=1.5,
                                                hover_color = 'grey',variable=self.check_var_vence15,onvalue=True,offvalue=False,
                                                checkbox_width=16,checkbox_height=16)
        self.trazer_vence15_check.place(x=8,y=2)
        
        #criando frame para checkbox trazer_todos 222
        self.trazer_todos_Frame = ctk.CTkFrame(self.tabview.tab('Relatório'),width=350,height=29,border_width=1.5, fg_color='#f2f2f2' )
        self.trazer_todos_Frame.place(x=32+90+88+94,y=235+85+32)
        #place(x=32+90+88+220,y=235+85+32)
        
        #criando checkbox para trazer da base de todos os itens selecionados
        self.check_var_trazer_todos = ctk.BooleanVar(value=False)
        self.trazer_todos_check = ctk.CTkCheckBox(self.trazer_todos_Frame , text=' Trazer dados de todos os itens',font=("Helvitica",14),
                                                border_color='grey', text_color='black',corner_radius=1,border_width=1.5,
                                                hover_color = 'grey',variable=self.check_var_trazer_todos,onvalue=True,offvalue=False,
                                                checkbox_width=16,checkbox_height=16)
        self.trazer_todos_check.place(x=8,y=2)
        
        #função para gerar dados para tabela de cada responsável do Relatório em pdf
        def pdf_data_gen():
            
            #tratando dados
            global dict_result_Resp, dict_Data_Table
            dict_result_Resp = {}
            
            if self.check_var_vence15.get() == False and self.check_var_trazer_todos.get() == False:
                
                for key,value in dict_Var_Resp.items():
                    
                    var,my_check,status = value
                    
                    if var.get() == True:
                        
                        if status == 'Vencidos':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][0], 'Vencido']]
                            
                        elif status == 'Vence_em_15':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][1],'V.em 15 dias']]
                            
                        else:
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][2], 'Ok']]
                            
                    
            elif self.check_var_vence15.get() == True and self.check_var_trazer_todos.get() == False:
                
                for key,value in dict_Var_Resp.items():
                    
                    var,my_check,status = value
                    
                    if var.get() == True:
                        
                        if status == 'Vencidos':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][0], 'Vencido'],
                                                     [dict_Data_Resp[key][1],'V.em 15 dias']]
                            
                        elif status == 'Vence_em_15':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][1],'V.em 15 dias']]
                            
                        else:
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][2], 'Ok']]
                            
            
            else:
                
                for key,value in dict_Var_Resp.items():
                    
                    var,my_check,status = value
                    
                    if var.get() == True:
                        
                        if status == 'Vencidos':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][0], 'Vencido'],
                                                     [dict_Data_Resp[key][1],'V.em 15 dias'],
                                                     [dict_Data_Resp[key][2], 'Ok']]
                            
                        elif status == 'Vence_em_15':
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][1],'V.em 15 dias'],
                                                     [dict_Data_Resp[key][2], 'Ok']] 
                            
                        else:
                            
                            dict_result_Resp[key] = [[dict_Data_Resp[key][2], 'Ok']]
                            
                    
            
            connection = sql.connect(f"{DB_caminho}")
            blinker = connection.cursor()
            
            dict_Data_Table = {}
            
            for key in dict_result_Resp.keys():
                
                data_list = []
            
                for n in range(len(dict_result_Resp[key])):
                    
                    
                    for i in range(len(dict_result_Resp[key][n][0])):
                    
                        blinker.execute(f"""SELECT Identificador,Id,Código,Validade,Volume FROM {Table_Stock} 
                                        WHERE Id = {dict_result_Resp[key][n][0][i]}""")
                        item = blinker.fetchone()
                        row = [item[0],item[1],item[2],item[3],'',item[4],dict_result_Resp[key][n][1],'','']  
                        data_list.append(row)
                
                
                dict_Data_Table[key] = data_list        
                        
            connection.close()
            
            # return dict_result_Resp
        
        
        #criando botão para gerar relatório✔️
        self.select_Ok_button = ctk.CTkButton(self.tabview.tab('Relatório'),text='📋  Gerar Relatório  ',command = pdf_data_gen , 
                                font=("helvitica",20,'bold'), height=30, width=258,corner_radius=8,border_width=1.5 ,#border_color='',
                                fg_color = '#080278',hover_color = '#037')
        self.select_Ok_button.place(x=32,y=235+85+28)

if __name__ == "__main__":
    aplicativo = App()
    aplicativo.mainloop()

# for n,i in dict_Data_Resp.items():
    
#     print(n,'\n',i,'\n')

# for key,value in dict_Var_Resp.items():
#     var,my_check,status = value
#     print(key,var.get(),status)

# print(dict_result_Resp,'\n')   
for k,v in dict_Data_Table.items():
    print('\n',k)
    for n in v:
        print(n)

