import customtkinter as ctk
from customtkinter import *

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter

from reportlab.pdfbase import pdfmetrics 
from reportlab.pdfbase.ttfonts import TTFont

from datetime import datetime

from csv import reader

from os import listdir, remove, startfile, mkdir, getlogin, path

# from time import time

from shutil import copy2

from customtkinter import filedialog

from tkinter import *
from tkinter.ttk import *
from tkinter import messagebox
from tkcalendar import *

from PIL import Image

from random import shuffle

import sqlite3 as sql

from datetime import datetime
from time import time, mktime

# date_epoch = mktime(datetime.strptime('23/06/2024', "%d/%m/%Y").timetuple())
# print(date_epoch)
# print(time())


#GERANDO BASE DE DADOS PARA ETIQUETAS
def Data_Gen():
    
    listaN = list(range(10000,100000))

    listaN1 = list(range(100000,1000000))

    listaN2 = list(range(1000000,10000000))

    shuffle(listaN)

    shuffle(listaN1)

    shuffle(listaN2)

    Lista_Geral = listaN + listaN1 + listaN2 
    
    
    diret = mkdir('main_files/Label Data-Frame')


    count = 0
    while count != 1000-1:
        with open(f'main_files/Label Data-Frame/Label_Data-{count}.csv','w') as arq:
            
            # tempo_inicial = time()
            
            for n in range(0+(10000*count),10000+(10000*count)):
                if n == 10000+(10000*count)-1:
                    arq.write(f'{Lista_Geral[n]}')
                    break
                arq.write(f'{Lista_Geral[n]}\n')
                # Lista_Geral.pop(0)
                
            # tempo_final = time() 
            # print(f'{tempo_final - tempo_inicial:.1f} segundos')
            print(f'Label_Data-{count} CRIADO\n')
            
            count += 1
    


#OBTENDO O CAMINHO PARA SALVAR PDF EM LOCAL DESEJADO
def Getting_Path():
    
    caminho = filedialog.askdirectory(title = "Selecione sua pasta de destino")
    
    return caminho
    



#LENDO O ARQUIVO, RETORNANDO LISTA E FAZENDO FOLLOW-UP
def Reading_Data():
    
    lista_arq = listdir('main_files/Label Data-Frame')
    
    #CASO OS DADOS TENHAM SE ESGOSTADOS
    if lista_arq == []:
        listaNF = []
        return listaNF
    
    #LENDO OS DADOS
    with open(f'main_files/Label Data-Frame/{lista_arq[0]}','r') as arq:
        csv_arq = list(reader(arq))
        
        #TRATANDO POSSÍVEIS ERROS DE ALTERAÇÃO DADOS
        while len(csv_arq) < 80:
            remove(f'main_files/Label Data-Frame/{lista_arq[0]}')
            lista_arq = listdir('main_files/Label Data-Frame')
            if lista_arq == []:
                listaNF = []
                return listaNF
                break
            with open(f'main_files/Label Data-Frame/{lista_arq[0]}','r') as arq:
                csv_arq = list(reader(arq))
        
        listaWT = []
        
        for n in range(0,80):
            listaWT.append(csv_arq[n][0])
            # print(csv_arq[n][0])
    
    #ATUALIZANDO OS ARQUIVOS DE DADOS:
    if len(csv_arq) > 80:
        
        with open(f'main_files/Label Data-Frame/{lista_arq[0]}','w') as arq:
            
            N = len(csv_arq[80:])
            for n in range(0,N):
                if n == N-1:
                    arq.write(f'{csv_arq[80:][n][0]}')
                    break
                arq.write(f'{csv_arq[80:][n][0]}\n')
        
        
    else:
        remove(f'main_files/Label Data-Frame/{lista_arq[0]}')
        
    
    return listaWT




#GERANDO O ARQUIVO PDF DE ETIQUETAS COM IDs
def Label_Model(listaWT,tipo,caminho):
    
    #PARÂMETROS DE ENTRADA
    c = caminho
    t = tipo #EC,PT,MP or GR
    l = listaWT
    
    #CASO SE ESGOTE O BANCO DE DADOS
    if l == [] :
        
        count = 0
        lista_pg = []
        for n in range(0,20):
            lista_lnh = []
            for i in range(0,4):
                # print(count)
                lista_lnh.append('NoDataFound')
                count += 1
                
        
            lista_pg.append(lista_lnh)
    
    #TRATANDO LISTA DE IDS
    else:
        count = 0
        # lista = []
        # for j in range(0,80):
        lista_pg = []
        for n in range(0,20):
            lista_lnh = []
            for i in range(0,4):
                # print(count)
                lista_lnh.append(f'{t} '+str(l[count])[0:2]+
                                      ' '+str(l[count])[2:4]+
                                      ' '+str(l[count])[4:])
                count += 1
                
        
            lista_pg.append(lista_lnh)
        # lista.append(lista_pg)
    
    time_mark = str(datetime.now())[:-7].replace(':',';')
    
    file_name = f'Etiquetas {time_mark} {getlogin()}.pdf'
    
    f = 25.4/72
    
    #CRIANDO PDF DE ETIQUETAS COM REPORTLAB
    pdf = canvas.Canvas(f'main_files/PDFs_done/{file_name}',pagesize = letter)
    
    font = 'arialbd.ttf'
    pdfmetrics.registerFont(TTFont(font, 'main_files/'+font))
    
    
    # count = 0
    # for pg in lista:
        
    count1 = 0
    for linha in lista_pg:
        
        count2 = 0 
        for cell in linha:
            pdf.drawBoundary(1, (14.3+0.85)/f+count2*(47.5/f),
                              254/f-count1*(12.7/f), 44/f, 10.8/f)
            pdf.setFont(font,18)
            pdf.drawCentredString((13.2+0.3)/f+(47.5/(2*f))+count2*(47.5/f),
                                  250.8/f+(12.7/(2*f))-count1*(12.7/f),
                                  str(lista_pg[count1][count2]))
            count2 += 1
        
        count1 += 1
            
        # count += 1
        # pdf.showPage()
        
    pdf.save()
    
    #SALVANDO CÓPIA DO ARQUIVO
    copy2(f'main_files/PDFs_done/{file_name}', c)
    
    #ABRINDO ARQUIVO
    startfile(c+f'/{file_name}')

# PEGANDO INFORMAÇÕES DA TELA
root = Tk()
ScreenX,ScreenY = root.winfo_screenwidth(),root.winfo_screenheight()
root.destroy()
# print(ScreenX,ScreenY)



######## CRIANDO E MANIPULANDO BANCO DE DADOS EM SQL ########################################### 
DB_Name = 'Stock Data'
DB_caminho = f'main_files/Data Base/{DB_Name}.db'
Table_Stock = 'Stock_Data'
Table_Trace = 'Stock_Data_Trace'
Table_Resp =  'Stock_Data_Resp'
Table_Códigos = 'Stock_Data_Cod'
Table_Correções = 'Stock_Data_Corrections'

#Crinado tabela do banco de dados
def create_db():
    
    if path.exists(DB_caminho) == False:
        
        if path.exists('main_files/Data Base') == False:
            
            mkdir('main_files/Data Base')
        
        connection = sql.connect(f'{DB_caminho}')
        blinker = connection.cursor() #como se fosse o cursor do prompt do SQL
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Stock}(   Identificador TEXT,
                                                                        Id INTEGER PRIMARY KEY,
                                                                        Código NUMERIC,
                                                                        Validade NUMERIC,
                                                                        Responsável TEXT,
                                                                        Volume NUMERIC,
                                                                        Obs TEXT,
                                                                        Time_Stamps_Login NUMERIC
                                                                        )""")
        connection.commit()

        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Trace}(   Identificador TEXT,
                                                                        Id INTEGER,
                                                                        Código NUMERIC,
                                                                        Validade NUMERIC,
                                                                        Responsável TEXT,
                                                                        Volume NUMERIC,
                                                                        Obs TEXT,
                                                                        Time_Stamps_Login NUMERIC,
                                                                        Time_Stamps_Login_Trace NUMERIC,
                                                                        Status TEXT
                                                                        )""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Resp}(Responsáveis TEXT)""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Códigos}(Códigos NUMERIC)""")
        connection.commit()
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('')""")
        connection.commit()
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('')""")
        connection.commit()
        
        blinker.execute(f"""CREATE TABLE IF NOT EXISTS {Table_Correções}(old TEXT,
                                                                         new TEXT,
                                                                         Time_Stamps_Login NUMERIC)""")
        connection.commit()
        
        
        connection.close()
    
create_db()    

#Buscando dados    
def fetch_itens(tabela):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT * FROM {tabela}")
    itens = blinker.fetchall() #me retorna uma lista de tuplas
    connection.close()
    
    return itens

#criando a função buscar para sistema de busca filtrado
def buscar(Filtro,Valor_Busca):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    if Filtro == 'Id':
        blinker.execute(f"SELECT * FROM {Table_Stock} WHERE {Filtro} = {Valor_Busca}")
        itens = blinker.fetchall() 
    else:
        blinker.execute(f"SELECT * FROM {Table_Stock} WHERE {Filtro} = '{Valor_Busca}'")
        itens = blinker.fetchall()
    connection.close()
    
    return itens

#convertendo lista de tuplas para lista
def tuple_to_list(tupla):
    lista = []
    for linha in tupla:
        lista.append(linha[0])
    lista.sort()
    return lista
    

#craindo função para identificar se um ID já foi cadastrado
def id_exists(ID):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Stock} WHERE Id = {ID}") #SELECT COUNT(*) FROM {Table} WHERE Id = {ID}
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False                                                  #result = blinker.fetchone
    
#craindo função para identificar se um Código já foi cadastrado
def codigo_exists(Código):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Códigos} WHERE Códigos = '{Código}'")
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False 

#craindo função para identificar se uma pessoa já foi cadastrada
def resp_exists(Responsável):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT 1 FROM {Table_Resp} WHERE Responsáveis = '{Responsável}'")
    result =  str(blinker.fetchone())[1] 
    if result == '1':
        return True
    else:
        return False 

#buscando OBS para mostrar no campo de observações
def fetch_OBS(ID):
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f"SELECT Obs FROM {Table_Stock} WHERE id = {ID}")
    itens = blinker.fetchall()[0] #me retorna uma lista de tuplas
    connection.close()
    
    return itens

#Inserindo dados do íten
def insert_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS):
    
    connection = sql.connect(f"{DB_caminho}")
    Time_Stamps_Login = str(datetime.now())+str(getlogin())
    blinker = connection.cursor()
    blinker.execute(f"""INSERT INTO {Table_Stock}(  Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login) VALUES
                                                    ('{Identificador}',
                                                     {ID},
                                                    '{Código}',
                                                    '{Validade}',
                                                    '{Responsável}',
                                                    '{Volume}',
                                                    '{OBS}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}')""")
    connection.commit()
    
    if codigo_exists(Código) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('{Código}')""")
        connection.commit()
    else:
        pass
    
    if resp_exists(Responsável) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('{Responsável}')""")
        connection.commit()
    else:
        pass
    
    
    connection.close()
    
#Atualizando itens
def update_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f'SELECT * FROM {Table_Stock} WHERE Id = {ID}')
    item = blinker.fetchall()
    blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login,
                                                    Time_Stamps_Login_Trace,
                                                    Status) VALUES
                                                    ('{item[0][0]}',
                                                     {item[0][1]},
                                                    '{item[0][2]}',
                                                    '{item[0][3]}',
                                                    '{item[0][4]}',
                                                    '{item[0][5]}',
                                                    '{item[0][6]}',
                                                    '{item[0][7]}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                    'UPDATED')""")
    connection.commit()

    blinker.execute(f"""UPDATE {Table_Stock} SET    Identificador = '{Identificador}',
                                                    Id = {ID},
                                                    Código = '{Código}',
                                                    Validade = '{Validade}',
                                                    ResponsáveL = '{Responsável}',
                                                    Volume = '{Volume}',
                                                    Obs = '{OBS}',
                                                    Time_Stamps_Login = '{str(datetime.now())[:19]+' '+str(getlogin())}'
                                                    WHERE Id = {ID}""")
                                                    
    connection.commit()
    
    if codigo_exists(Código) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Códigos}(Códigos) VALUES ('{Código}')""")
        connection.commit()
    else:
        pass
    
    if resp_exists(Responsável) == False:
        
        blinker.execute(f"""INSERT INTO {Table_Resp}(Responsáveis) VALUES ('{Responsável}')""")
        connection.commit()
    else:
        pass
    
    connection.close()

#Deletando dados
def delete_itens(ID):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    blinker.execute(f'SELECT * FROM {Table_Stock} WHERE Id = {ID}')
    item = blinker.fetchall()
    blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                    Id,
                                                    Código,
                                                    Validade,
                                                    ResponsáveL,
                                                    Volume,
                                                    Obs,
                                                    Time_Stamps_Login,
                                                    Time_Stamps_Login_Trace,
                                                    Status) VALUES
                                                    ('{item[0][0]}',
                                                     {item[0][1]},
                                                    '{item[0][2]}',
                                                    '{item[0][3]}',
                                                    '{item[0][4]}',
                                                    '{item[0][5]}',
                                                    '{item[0][6]}',
                                                    '{item[0][7]}',
                                                    '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                    'DELETED')""")
    connection.commit()

    blinker.execute(f'DELETE FROM {Table_Stock} WHERE Id = {ID}')
    connection.commit()
    connection.close()
    
#lista de itens vencidos
def lista_vencidos():
    
    Base_total = fetch_itens(Table_Stock)
    itens_vencidos = []
    for item in Base_total:
        if (mktime(datetime.strptime(item[3], "%d/%m/%Y").timetuple())+86399) <= time():
            itens_vencidos.append(item)
    return itens_vencidos

#criando função para correção dos dados de responsáveis e códigos
def data_correction(data_wrong,data_right,campo,correction_type):
    
    connection = sql.connect(f"{DB_caminho}")
    blinker = connection.cursor()
    
    if campo == 'Responsáveis':
        
        if correction_type == 'Atualizar':
            
            if resp_exists(data_right) == False:
                blinker.execute(f"""UPDATE {Table_Resp} SET Responsáveis = '{data_right}' 
                                WHERE Responsáveis = '{data_wrong}'""")
                connection.commit()
            else:
                blinker.execute(f"DELETE FROM {Table_Resp} WHERE Responsáveis = '{data_wrong}'")
                connection.commit()
            
            blinker.execute(f"""INSERT INTO {Table_Correções} (old,new,Time_Stamps_Login)
                                VALUES ('{data_wrong}','{data_right}',
                                        '{str(datetime.now())[:19]+' '+str(getlogin())+' Responsável'}')""")
            connection.commit()
            
            blinker.execute(f"""SELECT * FROM {Table_Stock} WHERE Responsável = '{data_wrong}'""")
            itens = blinker.fetchall()
            
            for item in itens:
                blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                                Id,
                                                                Código,
                                                                Validade,
                                                                ResponsáveL,
                                                                Volume,
                                                                Obs,
                                                                Time_Stamps_Login,
                                                                Time_Stamps_Login_Trace,
                                                                Status) VALUES
                                                                ('{item[0]}',
                                                                 {item[1]},
                                                                '{item[2]}',
                                                                '{item[3]}',
                                                                '{item[4]}',
                                                                '{item[5]}',
                                                                '{item[6]}',
                                                                '{item[7]}',
                                                                '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                                'Correção-Código')""")
            connection.commit()
            
            for item in itens:
                blinker.execute(f"""UPDATE {Table_Stock} SET Responsável = '{data_right}' 
                                WHERE Id = {item[1]}""")
            connection.commit()
            connection.close()
        
        else:
            
            blinker.execute(f"DELETE FROM {Table_Resp} WHERE Responsáveis = '{data_wrong}'")
            connection.commit()
            connection.close()
    
    else:
        
        if correction_type == 'Atualizar':
            
            if codigo_exists(data_right) == False:
                blinker.execute(f"""UPDATE {Table_Códigos} SET Códigos = '{data_right}' 
                                WHERE Códigos = '{data_wrong}'""")
                connection.commit()
            else:
                blinker.execute(f"DELETE FROM {Table_Códigos} WHERE Códigos = '{data_wrong}'")
                connection.commit()
            
            blinker.execute(f"""INSERT INTO {Table_Correções} (old,new,Time_Stamps_Login)
                                VALUES ('{data_wrong}','{data_right}',
                                        '{str(datetime.now())[:19]+' '+str(getlogin())+' Código'}')""")
            connection.commit()
            
            blinker.execute(f"""SELECT * FROM {Table_Stock} WHERE Código = '{data_wrong}'""")
            itens = blinker.fetchall()
            
            for item in itens:
                blinker.execute(f"""INSERT INTO {Table_Trace} ( Identificador,
                                                                Id,
                                                                Código,
                                                                Validade,
                                                                ResponsáveL,
                                                                Volume,
                                                                Obs,
                                                                Time_Stamps_Login,
                                                                Time_Stamps_Login_Trace,
                                                                Status) VALUES
                                                                ('{item[0]}',
                                                                 {item[1]},
                                                                '{item[2]}',
                                                                '{item[3]}',
                                                                '{item[4]}',
                                                                '{item[5]}',
                                                                '{item[6]}',
                                                                '{item[7]}',
                                                                '{str(datetime.now())[:19]+' '+str(getlogin())}',
                                                                'Correção-Responsável')""")
            connection.commit()
            
            for item in itens:
                blinker.execute(f"""UPDATE {Table_Stock} SET Código = '{data_right}' 
                                WHERE Id = {item[1]}""")
            connection.commit()
            connection.close()
        
        else:
            
            blinker.execute(f"DELETE FROM {Table_Códigos} WHERE Códigos = '{data_wrong}'")
            connection.commit()
            connection.close()
                
                            
    
    



######## CRIANDO INTERFACE GRÁFICA ################################################################
class App(ctk.CTk): # App = ctk.CTk
    
    def __init__(self):
        super().__init__()
        self.window_config()
        self.tema_config()
        self.frontend()
        
        
        
    def window_config(self):
        self.title("SPSLab - Controle de Armazenamento")
        x1,y1 = 1000,650
        self.iconbitmap("PPG ICON.ico")
        self.geometry(f"{x1}x{y1}+{(ScreenX-x1)//2}+{(ScreenY-y1)//4}")
        self._set_appearance_mode("system")
        # self.resizable(width=False, height=False)
        self.minsize(width=x1,height=y1)
        
    
    def tema_config(self):
        
        self.switch_var = ctk.StringVar(value="system")
        
        def set_tema():
            
            if self.switch_var.get() =="light":
                ctk.set_appearance_mode("light")
                
            else:
                ctk.set_appearance_mode("dark")
                
                
        
        self.switch = ctk.CTkSwitch(self, text = None, variable=self.switch_var, 
                                    onvalue= "dark", offvalue="light", command=set_tema)
        self.switch.place(x=25,y=20)
        
    
    def frontend(self):
        
        self.Label_logo = ctk.CTkLabel(self, text="                      We protect and\n                      beautify the world™", 
                                       font=("helvitica",12), justify = "left" )
        self.Label_logo.place(relx=0.02,rely=0.927)#relx=0.09,rely=0.93)
        
        #Logo
        if self.switch_var.get() =="light":
            logo = ctk.CTkImage(light_image=Image.open("PPG LOGO2.png"), size=(250*0.25,90*0.25))
        else:
            logo = ctk.CTkImage(dark_image=Image.open("PPG LOGO2.png"), size=(153*0.40,120*0.40))
            
        self.logo_Label = ctk.CTkLabel(self, text=None,image=logo)
        self.logo_Label.place(relx=0.02,rely=0.91)
        
        
        self.Label = ctk.CTkLabel(self, text="Sistema de Controle de Armazenamento", font=("arial bold",30))
        self.Label.pack(pady = 20)
        
        self.tabview = ctk.CTkTabview(self,
                                      width = 700,
                                      height = 510,
                                      corner_radius = 8,
                                      border_width = 2,
                                      segmented_button_fg_color="grey",
                                      segmented_button_selected_color="#037",
                                      segmented_button_unselected_hover_color="#111",
                                      segmented_button_unselected_color="#333")
        self.tabview.pack(pady = 0)
        self.tabview.add("Controle de Dados")
        self.tabview.add("Relatório")
        self.tabview.add("Etiquetas")
        self.tabview.add("Correções")
        self.tabview.tab("Etiquetas").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Controle de Dados").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Relatório").grid_columnconfigure(1, weight=1)
        self.tabview.tab("Correções").grid_columnconfigure(1, weight=1)
        
        
        ##### CRINADO ABA DE "Etiquetas" #################################################################
        
        self.Hang_Tags_Label = ctk.CTkLabel(self.tabview.tab("Etiquetas"), text="Escolha um Identificador",
                                            font=("arial bold",30))
        self.Hang_Tags_Label.pack(pady=20)
        
        #criando variável para radiobuttons
        self.Tag_type = ctk.IntVar(value=0)
        
        #criando função para pegar valores de cada etiqueta
        def tipo():
            dictionary = {1:'EC',2:'PT',3:'MP',4:'GR'}
            return dictionary[self.Tag_type.get()]
        
        #criando RadioButtons
        dtry = {1:' EC',2:' PT',3:' MP',4:' GR'}
        for n in range(1,5):
            self.RBt = CTkRadioButton(self.tabview.tab("Etiquetas"), text = dtry[n], command = tipo , 
                                      variable = self.Tag_type , value = n, font=("arial bold",40))
            self.RBt.pack(pady=12)
        
        #definindo função para geração de PDF de etiquetas
        def Gerar_PDF():
            
            if self.Tag_type.get() != 0:
                
                try:
                    caminho = Getting_Path()
                    
                    Label_Model(Reading_Data(), tipo(), caminho)
                except:
                    pass
                
            else:
                messagebox.showerror(title='Erro de Seleção', message='Por favor, selecione\n   uma das opções' )
            pass
        
        #criando botão para geração de PDF de etiquetas
        self.B1 = CTkButton(self.tabview.tab("Etiquetas"), text = "Gerar Etiquetas",command = Gerar_PDF, 
                                font=("arial bold",18),fg_color="#ba0606")
        self.B1.pack(pady = 25)
        
        #criando Label de Aviso
        self.Label_aviso = ctk.CTkLabel(self.tabview.tab("Etiquetas"), text="* No momento da impressão selecione o tamanho Carta",
                                            font=("arial",12))
        self.Label_aviso.pack()
        
        
        ##### CRIANDO ABA DE "Controle de Dados" #################################################################
        
        # criando calendário para seleção de validade
        self.Calen_Validade = Calendar(self.tabview.tab("Controle de Dados"),selectmode = 'day', 
                                       date_pattern = 'dd/mm/y',locale="pt_BR" )
        self.Calen_Validade.place(x=415,y=25)
        
        # criando barra de buscar de itens
        self.Label_Busca_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Busca:', 
                                              font=("arial",16,"bold"))
        self.Label_Busca_entry.place(x=18.5,y=0)
        self.Busca_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                        width=200, height=35, font=('arial',14))
        self.Busca_entry.place(x=18,y=25)
        
        
        
        # criando Label para ComboBox de filtro
        self.Label_Filtro = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Filtro:', 
                                         font=("arial",14,"bold"))
        self.Label_Filtro.place(x=18.5+210+45,y=0)
        # criando ComboBox de filtro para busca de itens
        self.Filtro_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values=['','ID','Vencidos','Identif.','Código','Resp.','Validade','Volume'] ,
                                        width=130, height=35, font=('arial',14,'bold'),corner_radius=8)
        self.Filtro_entry.place(x=18+210+45,y=25)
        
        
        # criando Label para entry Identificação
        self.Label_Ident = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Identificador:',
                                        font=("arial",14,"bold"))
        self.Label_Ident.place(x=18.5,y=50+40)
        # criando entry para Identificação
        self.Identficador_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values=['','EC','PT','MP','GR'] ,
                                        width=120, height=35, font=('arial',14,'bold'),corner_radius=8)
        self.Identficador_entry.place(x=18.5,y=50+65)
        
        
        # criando Label da entry para IDs
        self.Label_ID_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='ID:', font=("arial",14,"bold"))
        self.Label_ID_entry.place(x=18.5+135,y=50+40)
        # criando entry para IDs
        self.ID_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                        width=118, height=35, font=('arial',14))
        self.ID_entry.place(x=18+135,y=50+65)
        
        
        # criando Label da entry para Volume
        self.Label_Volume_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Volume:',font=("arial",14,"bold"))
        self.Label_Volume_entry.place(x=18.5+135+115+17,y=50+40)
        # criando entry para Volume
        self.Volume_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),
                                        values=['','3,6 L','5 L','10 L','18 L','20 L','50 L','500 mL','250 mL', 'Caixa'],
                                        width=118, height=35, font=('arial',14,'bold'),corner_radius=8 )
        self.Volume_entry.place(x=18+135+115+17,y=50+65)
        
        
        #variável para inserir como lista de Responsáveeis  no combobox Responsável
        self.Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
        # criando Label da entry para Responsáveis
        self.Label_Responsavel_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Responsável:',
                                                    font=("arial",14,"bold"))
        self.Label_Responsavel_entry.place(x=18.5,y=50+40+63)
        # criando entry para Responsáveis
        self.Responsavel_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),
                                        values = self.Responsáveis,
                                        width=235, height=35, font=('arial',14),corner_radius=8 )
        self.Responsavel_entry.place(x=18,y=50+65+63)
        
        #variável para inserir códigos com lista no combobox códigos
        self.códigos = tuple_to_list(fetch_itens(Table_Códigos))
        # criando Label da entry para Códigos
        self.Label_Codigo_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Código:', 
                                               font=("arial",14,"bold"))
        self.Label_Codigo_entry.place(x=18.5+265-15,y=50+40+63)
        # criando Label da entry para Códigos
        self.Codigo_entry = ctk.CTkComboBox(self.tabview.tab("Controle de Dados"),values = self.códigos , 
                                        width=136, height=35, font=('arial',14))
        self.Codigo_entry.place(x=18+265-17,y=50+65+63)
        
        
        # criando Label da entry para Observações
        self.Label_OBS_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='OBS:', font=("arial",14,"bold"))
        self.Label_OBS_entry.place(x=18.5,y=50+40+63+63)
        # criando entry para Observações
        self.OBS_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), 
                                      width=217.5, height=35, font=('arial',14))
        self.OBS_entry.place(x=18,y=50+65+63+60)
        
        
        # criando Label da entry para Validade
        self.Label_Validade_entry = ctk.CTkLabel(self.tabview.tab("Controle de Dados"), text='Validade:', font=("arial",15,"bold"))
        self.Label_Validade_entry.place(x=18.5+215+67-55,y=50+40+63+63)
        # criando entry para Validade
        self.Validade_entry = ctk.CTkEntry(self.tabview.tab("Controle de Dados"), placeholder_text= 'dd/mm/AAAA',
                                        placeholder_text_color='#333', width=115, height=35, font=('arial',14))
        self.Validade_entry.place(x=18+215+67-51.5,y=50+65+63+60)
        
        
        #criando função para pegar data do calendário
        def take_date():
            self.Validade_entry.delete(0,END)
            self.Validade_entry.insert(0, f'{self.Calen_Validade.get_date()}')
            
        #criando botão para pegar data do calendário
        self.Validade_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='🗓',command = take_date,text_color = 'black',#command =, 
                                font=("arial",18), height=35, width=35,corner_radius=8, #border_color='silver',
                                border_width=1.5, fg_color = 'silver', hover_color ='white'  ) 
                               #, border_color='silver')
        self.Validade_Button.place(x=18+215+12+120.5,y=50+65+63+60)
        
        #criando função para limpar tudo
        def clear_all():
            self.Identficador_entry.set('')
            self.ID_entry.delete(0,END)
            self.Codigo_entry.set('')
            self.Validade_entry.delete(0,END)
            self.Responsavel_entry.set('')
            self.Volume_entry.set('')
            self.OBS_entry.delete(0,END)
            if self.Filtro_entry.get() == 'Vencidos':
                self.Filtro_entry.set('')
            self.Busca_entry.delete(0,END)
            # add_to_TREEVIEW()
            self.TREEVIEW.selection_remove(self.TREEVIEW.focus())
            add_to_TREEVIEW()
        
        #criando função limpar dados da TREEVIEW
        def clear(*clicked):
            
            if clicked:
                self.TREEVIEW.selection_remove(self.TREEVIEW.focus())
            self.Identficador_entry.set('')
            self.ID_entry.delete(0,END)
            self.Codigo_entry.set('')
            self.Validade_entry.delete(0,END)
            self.Responsavel_entry.set('')
            self.Volume_entry.set('')
            self.OBS_entry.delete(0,END)
            

        #criando função para mostrar dados selecionados
        def display_data(event):
            
            selected_item = self.TREEVIEW.focus()
            
            if selected_item:
                row = self.TREEVIEW.item(selected_item)['values']
                clear()
                self.Identficador_entry.set(row[0])
                self.ID_entry.insert(0,row[1])
                self.Codigo_entry.set(row[2])
                self.Validade_entry.insert(0,row[3])
                self.Responsavel_entry.set(row[4])
                self.Volume_entry.set(row[5])
                self.OBS_entry.insert(0, fetch_OBS(row[1])[0])
            else:
                pass
        
        #criando função para adicionar a TREEVIEW
        def add_to_TREEVIEW():
            dict_Filtro = {'ID':'Id',
                           'Identif.':'Identificador',
                           'Código':'Código',
                           'Resp.':'Responsável',
                           'Validade':'Validade',
                           'Volume':'Volume'}
            
            if self.Busca_entry.get().upper() == 'VENCIDOS' or self.Filtro_entry.get() == 'Vencidos':
                itens = lista_vencidos()
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)
            
            elif self.Filtro_entry.get() == '' or self.Busca_entry.get() == '':
                itens = fetch_itens(Table_Stock)
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                
            
            elif self.Filtro_entry.get() == 'Resp.':
                itens = buscar(dict_Filtro[self.Filtro_entry.get()], self.Busca_entry.get().strip().title())
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)    
            else:     
                itens = buscar(dict_Filtro[self.Filtro_entry.get()], self.Busca_entry.get().strip().upper())
                self.TREEVIEW.delete(*self.TREEVIEW.get_children())
                for item in itens:
                    self.TREEVIEW.insert('', END, values=item)
                return len(itens)

        #criando função para inserção de itens
        def INSERIR():
            
            Identificador = self.Identficador_entry.get()
            ID = self.ID_entry.get().strip().replace(' ', '')
            Responsável = self.Responsavel_entry.get().title().strip()
            Código = self.Codigo_entry.get().upper().strip()
            Validade = self.Validade_entry.get().strip()
            Volume = self.Volume_entry.get().strip()
            OBS = self.OBS_entry.get().strip()
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao inserir ID','Por favor, insira um número \ninteiro válido de 5 a 8 dígitos \nno campo ID. ')
            
            elif id_exists(ID):
                messagebox.showerror('Erro ao inserir ID',f'Não é possível inserir o \nitem pois o ID {ID} \njá foi cadastrado.\n\nPor favor, insira um ID \nainda não utilizado.')
            
            elif ( (len(Validade.split('/')[0])!=2 or Validade.split('/')[0].isdigit == False) or
                   (len(Validade.split('/')[1])!=2 or Validade.split('/')[1].isdigit == False) or
                   (len(Validade.split('/')[2])!=4 or Validade.split('/')[2].isdigit == False) ):
                messagebox.showerror('Erro ao inserir a Validade','Por favor, insira a data de validade \nno padrão dd/mm/AAAA')
            
            elif (Identificador == '' and Identificador != 'EC' and Identificador != 'PT' and Identificador != 'MP' and Identificador != 'GR'
                  or Responsável == '' or Código == '' or Volume == ''):
                messagebox.showerror('Erro ao inserir dados', 'Por favor, preencha todos \nos campos pertinentes')
                
            else:
                
                insert_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS)
                
                #adicionando novos Códigos a lista de Códigos
                if Código in self.códigos:
                    pass
                else:
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                
                #adicionando novos Nomes a lista de responsáveis
                if Responsável in self.Responsáveis:
                    pass
                else:
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)

                add_to_TREEVIEW()
                messagebox.showinfo('Inserção bem sucedida!',f'O item {ID} foi inserido com sucesso!')
                    
        
        #criando botão para INSERIR dados
        self.INSERIR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='➕ Inserir',command = INSERIR , 
                                font=("arial",12), height=30, width=65,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#080278')
        self.INSERIR_Button.place(x=18+215+12+117+58,y=50+65+63+54)
        

        #criando função para deletar itens
        def DELETAR():
            
            ID = self.ID_entry.get()
            
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao deletar ID','Por favor, selecione \no item que deseja deletar.\n\nOu, insira um número inteiro \nválido de 5 a 8 dígitos \nno campo ID.')
            
            elif id_exists(ID) == False:
                messagebox.showerror('Erro ao deletar ID',f'Não é possível deletar o \nitem pois o ID {ID} \nainda não foi cadastrado.\n\nPor favor, tente deletar apenas \nitens existentes.')
            else:
                resposta = messagebox.askyesno('Atenção ao deletar', f'Tem certeza que deseja\ndeletar o item (ID: {ID})?')
                
                if resposta == 1:
                    delete_itens(ID)
                    add_to_TREEVIEW()
                    messagebox.showinfo('Exclusão bem sucedida!',f'Item {ID} deletado com sucesso.')
                    
                else:
                    pass
            
        #criando botão para DELETAR dados
        self.DELETAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✖️ Deletar',command = DELETAR, 
                                font=("arial",12), height=30, width=65,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#a60202', hover_color ='#ba2929' )
        self.DELETAR_Button.place(x=18+215+12+117+60+166,y=50+65+63+54)
        
        
        #criando função para atualização de dados
        def ATUALIZAR():
            
            Identificador = self.Identficador_entry.get()
            ID = self.ID_entry.get().strip().replace(' ', '')
            Responsável = self.Responsavel_entry.get().title().strip()
            Código = self.Codigo_entry.get().upper().strip()
            Validade = self.Validade_entry.get().strip()
            Volume = self.Volume_entry.get().strip()
            OBS = self.OBS_entry.get().strip()
            
            if ID.isnumeric() == False or len(ID) > 8 or len(ID) < 5:
                messagebox.showerror('Erro ao atualizar ID','Por favor, selecione \no item que deseja atualizar.\n\nOu, insira o ID que deseja\natualizar no campo ID. ')
            
            elif id_exists(ID) == False:
                messagebox.showerror('Erro ao atualizar ID',f'Não é possível atualizar o \nitem pois o ID {ID} \nainda não foi cadastrado.\n\nPor favor, atualize apenas itens \nexistentes.')
            
            elif ( (len(Validade.split('/')[0])!=2 or Validade.split('/')[0].isdigit == False) or
                   (len(Validade.split('/')[1])!=2 or Validade.split('/')[1].isdigit == False) or
                   (len(Validade.split('/')[2])!=4 or Validade.split('/')[2].isdigit == False) ):
                messagebox.showerror('Erro ao inserir a Validade','Por favor, insira a data de validade \nno padrão dd/mm/AAAA')
                
            elif (Identificador == '' and Identificador != 'EC' and Identificador != 'PT' and Identificador != 'MP' and Identificador != 'GR'
                  or Responsável == '' or Código == '' or Volume == ''):
                messagebox.showerror('Erro ao inserir dados', 'Por favor, preencha todos \nos campos pertinentes')
                
            else:
                  
                update_itens(Identificador, ID, Código, Validade, Responsável, Volume, OBS)
                
                #adicionando novos Códigos a lista de Códigos
                if Código in self.códigos:
                    pass
                else:
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                
                #adicionando novos Nomes a lista de responsáveis
                if Responsável in self.Responsáveis:
                    pass
                else:
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)

                add_to_TREEVIEW()
                messagebox.showinfo('Atualização bem sucedida!',f'O item {ID} foi atualizado com sucesso!')
              
                
        
        #criando botão para ATUALIZAR dados
        self.ATUALIZAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✏ Atualizar',command = ATUALIZAR, 
                                font=("arial",12), height=30, width=73,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#02783b', hover_color ='#179c57'  )
        self.ATUALIZAR_Button.place(x=18+215+12+117+60+77,y=50+65+63+54)
        
        #criando botão limpar
        self.LIMPAR_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='✨Limpar',text_color='black',command = clear_all ,  
                                font=("arial",11), height=20, width=30,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#e6a902', hover_color ='#b88702'  )#fg_color = 'silver', hover_color ='white')
        self.LIMPAR_Button.place(x=18,y=65)
        
        #criando função gatilho para botão de busca
        def busca_button():
            
            lista_filtro = ['ID','Vencidos','Identif.','Código','Resp.','Validade','Volume']
            
            if self.Busca_entry.get().upper() == 'VENCIDOS' or self.Filtro_entry.get() == 'Vencidos':
                resultado = add_to_TREEVIEW()
                messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} \nitens vencidos.')
            
            elif self.Filtro_entry.get() in lista_filtro and self.Busca_entry.get() != '':
                resultado = add_to_TREEVIEW()
                
                if resultado != 0 and self.Filtro_entry.get() != 'ID':
                    if resultado != 1:
                        messagebox.showinfo('Resultado da busca', f'Foram encontrados {resultado} itens.')
                    else:
                        messagebox.showinfo('Resultado da busca', f'Apenas 1 item foi encontrado.')
                        
                elif resultado != 0 and self.Filtro_entry.get() == 'ID':  
                    pass
                
                else:
                    messagebox.showinfo('Resultado da busca', 'Nenhum item foi encontrado.')
                    
            else:
                messagebox.showinfo('Busca vazia', 'Por favor, digite sua pesquisa\nna barra de busca e selecione\num dos filtros listados.')
        
        # criando botão de gatilho para  buscar de itens
        def take_entry_Busca():
            return self.Busca_entry.get()
        self.Busca_Button = ctk.CTkButton(self.tabview.tab("Controle de Dados"),text='🔍',text_color = 'black',command = busca_button , 
                                font=("arial",18), height=35, width=35,corner_radius=8, border_color='silver',
                                border_width=1.5, fg_color = 'silver', hover_color ='white'  ) 
        self.Busca_Button.place(x=18+208,y=25)
            
        ####  CRIANDO TREEVIEW PARA ABA "Controle de Dados"  #################################################
        
        #criando frame da treeview
        self.TREEVIEW_Frame = CTkFrame(self.tabview.tab("Controle de Dados"))
        self.TREEVIEW_Frame.place(x=18,y=285)
        
        #criando um estilo para Treeview
        self.style = Style(self.TREEVIEW_Frame)
        
        self.style.theme_use('clam')
        self.style.configure('Treeview', font = ("arial",9),foreground='black',background='silver',fieldbackround='black')
        self.style.map('Treeview', background=[('selected','#012563')])#'#036491')])
        
        #criando scrollbar para treeview
        self.TREEVIEW_scrollbar = Scrollbar(self.TREEVIEW_Frame)
        self.TREEVIEW_scrollbar.pack(side=RIGHT,fill=Y )
        
        #criando Treeview
        self.TREEVIEW = Treeview(self.TREEVIEW_Frame,yscrollcommand=self.TREEVIEW_scrollbar.set ,height=7 )
        self.TREEVIEW.pack()#place(x=18,y=285)
        #ativando o click da scrollbar
        self.TREEVIEW_scrollbar.config(command=self.TREEVIEW.yview)
        #criando colunas
        self.TREEVIEW['columns'] = ('Identif.','ID','Código','Validade','Responsável','Volume')
        self.TREEVIEW.column('#0', width=0, stretch=NO)
        self.TREEVIEW.column('Identif.',anchor=CENTER, width=70)
        self.TREEVIEW.column('ID',anchor=CENTER, width=102)
        self.TREEVIEW.column('Código',anchor=CENTER, width=110)
        self.TREEVIEW.column('Responsável',anchor=CENTER, width=132)
        self.TREEVIEW.column('Validade',anchor=CENTER, width=112)
        self.TREEVIEW.column('Volume',anchor=CENTER, width=101)
        
        #inserindo nome das colunas
        self.TREEVIEW.heading('Identif.', text='Identif.')
        self.TREEVIEW.heading('ID', text='ID')
        self.TREEVIEW.heading('Código', text='Código')
        self.TREEVIEW.heading('Responsável', text='Responsável')
        self.TREEVIEW.heading('Validade', text='Validade')
        self.TREEVIEW.heading('Volume', text='Volume')
        
        
        self.TREEVIEW.bind('<ButtonRelease>', display_data)
        
        add_to_TREEVIEW()
        
        ##### CRIANDO ABA DE "Correções" #################################################################
        
        #criando label de aviso
        self.Aviso_Label = ctk.CTkLabel(self.tabview.tab("Correções"), text = """***Use apenas para corrigir códigos ou responsáveis com erros de digitação.\n***Não use para alterar itens com cadastro incorreto!""",
                                        font=("arial",13), justify = "center")
        self.Aviso_Label.pack(pady=5)
        
        #criando frame para aba alterações
        self.Alteração_Frame = ctk.CTkFrame(self.tabview.tab("Correções"),
                                            width=700*0.5, height=510*0.75, border_color='grey',
                                            border_width = 2, fg_color='white')
        self.Alteração_Frame.pack(pady=10)
      
            
        #criando Label para correção de códigos velhos
        self.Label_Alteração_código = ctk.CTkLabel(self.Alteração_Frame, text='Correção de Códigos', text_color='#4e4f4f',
                                               font=("arial",16,"bold"))
        self.Label_Alteração_código.place(x = 30, y =17+5 )                                       
        self.Label_combo_código = ctk.CTkLabel(self.Alteração_Frame, text='Velho:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_código.place(x=30,y=50)
        #criando combobox para correção de códigos velhos
        self.combo_código = ctk.CTkComboBox(self.Alteração_Frame,values = self.códigos , 
                                        width=150, height=35, font=('arial',14))
        self.combo_código.place(x=29.5,y=50+25)
        
        #criando Label Novo para correção de códigos novos
        self.Label_combo_código = ctk.CTkLabel(self.Alteração_Frame, text='Novo:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_código.place(x=30+155,y=50)
        #criando combobox para correção de códigos novos
        self.entry_código_novo = ctk.CTkEntry(self.Alteração_Frame, 
                                        width=135, height=35, font=('arial',14))
        self.entry_código_novo.place(x=29.5+155,y=50+25)
        
        
        #criando Label para correção de responsáveis velhos
        self.Label_Alteração_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Correção de Responsáveis', text_color='#4e4f4f',
                                               font=("arial",16,"bold"))
        self.Label_Alteração_Resp.place(x = 30, y =17+130 )                                       
        self.Label_combo_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Velho:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_Resp.place(x=30,y=50+125)
        #criando combobox para correção de responsáveis velhos
        self.combo_Resp = ctk.CTkComboBox(self.Alteração_Frame,values = self.Responsáveis ,
                                        width=150, height=35, font=('arial',14))
        self.combo_Resp.place(x=29.5,y=50+25+125)
        
        #criando Label da combobox para correção de responsáveis novos
        self.Label_combo_Resp = ctk.CTkLabel(self.Alteração_Frame, text='Novo:', text_color='black',
                                               font=("arial",14,"bold"))
        self.Label_combo_Resp.place(x=30+155,y=50+125)
        #criando combobox para correção de responsáveis novos
        self.entry_Resp_novo = ctk.CTkEntry(self.Alteração_Frame, 
                                        width=135, height=35, font=('arial',14))
        self.entry_Resp_novo.place(x=29.5+155,y=50+25+125)
      
    
        #criando função para atualização de dados da aba correção
        def CORRIGIR_Atualizar():
            
            Código_wrong = self.combo_código.get()
            Código_right = self.entry_código_novo.get().upper().strip()
            
            Resp_wrong = self.combo_Resp.get()
            Resp_right = self.entry_Resp_novo.get().title().strip()
            
            
            
            if Código_wrong == ''  and Código_right == '' and Resp_wrong == '' and Resp_right == '':
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
                  
            if Código_wrong != '' and Resp_wrong != '':
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas uma \ncategoria por vez.')
                
            #condição código correto
            elif Código_wrong != ''  and Código_right != '' and Resp_wrong == '' and Resp_right == '':
                
                if codigo_exists(Código_wrong) == True:
                    
                    data_correction(Código_wrong, Código_right, 'Códigos', 'Atualizar')
                    
                    add_to_TREEVIEW()
                    
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                    
                    messagebox.showinfo('Atualização bem sucedida!',f'O item {Código_wrong} foi atualizado \npara {Código_right} com sucesso!')
                
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um código \njá cadastrado.')
                
            #condição responsável correto
            elif Código_wrong == ''  and Código_right == '' and Resp_wrong != '' and Resp_right != '':
                
                if resp_exists(Resp_wrong) == True:
                    
                    data_correction(Resp_wrong, Resp_right, 'Responsáveis', 'Atualizar')
                    
                    add_to_TREEVIEW()
                    
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)
                    
                    messagebox.showinfo('Atualização bem sucedida!',f'O item {Resp_wrong} foi atualizado \npara {Resp_right} com sucesso!')
                
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um responsável \njá cadastrado.')
            
            else:
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas uma \ncategoria por vez.')
                
        
        #criando função para exclusão de dados da aba correção
        def CORRIGIR_Deletar():
            
            Código_wrong = self.combo_código.get()
            Código_right = self.entry_código_novo.get().upper().strip()
            
            Resp_wrong = self.combo_Resp.get()
            Resp_right = self.entry_Resp_novo.get().title().strip()
            
            
            
            if Código_wrong == '' and Resp_wrong == '':
                messagebox.showerror('Erro ao Corrigir','Por favor, selecione o parâmetro \nque deseja corrigir.')
                  
            if Código_wrong != '' and Resp_wrong != '':
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas uma \ncategoria por vez.')
                  
            #condição código correto
            elif Código_wrong != '':
                
                if codigo_exists(Código_wrong) == True:
                    
                    data_correction(Código_wrong, Código_right, 'Códigos', 'Deletar')
                    
                    add_to_TREEVIEW()
                    
                    followup_Códigos = tuple_to_list(fetch_itens(Table_Códigos))
                    self.Codigo_entry.configure(values = followup_Códigos)
                    self.combo_código.configure(values = followup_Códigos)
                    
                    messagebox.showinfo('Exclusão bem sucedida!',f'O item {Código_wrong} foi excluído com sucesso!')
                
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um código \njá cadastrado.')
                
            #condição responsável correto
            elif Resp_wrong != '':
                
                if resp_exists(Resp_wrong) == True:
                    
                    data_correction(Resp_wrong, Resp_right, 'Responsáveis', 'Deletar')
                    
                    add_to_TREEVIEW()
                    
                    followup_Responsáveis = tuple_to_list(fetch_itens(Table_Resp))
                    self.Responsavel_entry.configure(values = followup_Responsáveis)
                    self.combo_Resp.configure(values = followup_Responsáveis)
                    
                    messagebox.showinfo('Exclusão bem sucedida!',f'O item {Resp_wrong} foi excluído com sucesso!')
                
                else:
                    messagebox.showerror('Erro ao Corrigir','Por favor, selecione um responsável \njá cadastrado.')
            
            else:
                messagebox.showerror('Erro ao Corrigir','Por favor, corrija apenas uma \ncategoria por vez.')
                
        #criando botão para ATUALIZAR dados
        self.ATUALIZAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='⬆ Atualizar',command = CORRIGIR_Atualizar , 
                                font=("arial",19), height=35, width=110,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#02783b', hover_color ='#179c57'  )
        self.ATUALIZAR_Button_correções.place(x=60,y=50+65+63+54+35)
        
          
        #criando botão deletar na aba correções
        self.DELETAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='❌ Deletar',command = CORRIGIR_Deletar , 
                                font=("arial",19), height=35, width=100,corner_radius=8, border_width=1.5 ,
                                fg_color = '#a60202', hover_color ='#ba2929' )
        self.DELETAR_Button_correções.place(x=185,y=50+65+63+54+35)
        
        
        #criando função para limpar aba correções
        def clear_corrections():
            
            self.combo_código.set('')
            self.entry_código_novo.delete(0,END)
        
            self.combo_Resp.get.set('')
            self.entry_Resp_novo.delete(0,END)
            
        
        
        #criando botão limpar
        self.LIMPAR_Button_correções = ctk.CTkButton(self.Alteração_Frame,text='✨Limpar',text_color='black',command = clear_corrections ,  
                                font=("arial",17), height=30, width=50,corner_radius=8, border_width=1.5 ,#border_color='',
                                fg_color = '#e6a902', hover_color ='#b88702'  )#fg_color = 'silver', hover_color ='white')
        self.LIMPAR_Button_correções.place(x=130,y=330)   


if __name__ == "__main__":
    aplicativo = App()
    aplicativo.mainloop()
